{
  "id": "stratum-formal-spec-v2.5",
  "title": "STRATUM Formal Specification",
  "version": "2.5.0-alpha",
  "description": "A layered specification framework for describing complex artifacts with formal guarantees",
  "namespace": "stratum.spec",
  "meta": {
    "subtitle": "A Formal System for Specifying Complex Artifacts",
    "abstract": "STRATUM v2.5.0-alpha introduces conformance levels (K0-K3) and adds the seventh guarantee G7 (Explainability). This ALPHA release defines the Kernel (K0) as a 2-hour reading path covering core data structures, well-formedness, six guarantees (G1-G6), and basic operations. K1 (Certified-Aware) adds G7 with irreducible unsat cores and the Policy System for automated remediation. Building on v2.4.4, this version includes: (1) schema evolution with compatibility rules (¬ß16), (2) STPA/FMEA hazard integration (¬ß27), (3) formal attenuation properties (¬ß28), (4) cross-standard DO-178C ‚Üî ISO 26262 traceability (¬ß29), (5) LSL-style tier boundary semantics (¬ß30), and (6) comprehensive 100+ term glossary (¬ß30). The specification maintains backward compatibility while enabling regulated industry adoption through explicit conformance tiers.",
    "keywords": [
      "formal specification",
      "layered architecture",
      "traceability",
      "dependency management",
      "type system",
      "constraint validation",
      "cascade propagation",
      "CRDT",
      "concurrency",
      "verification lifecycle",
      "query language",
      "schema evolution",
      "distributed consensus",
      "incremental validation"
    ],
    "revisionNotes": [
      {
        "section": "¬ß5",
        "description": "Type system soundness fixes (invariant layer parameters)",
        "type": "fix",
        "since": "2.0"
      },
      {
        "section": "¬ß2.4",
        "description": "Decidable constraint language (QF-LIRA + EUF)",
        "type": "fix",
        "since": "2.0"
      },
      {
        "section": "¬ß7.3",
        "description": "Explicit lattice structure for merge",
        "type": "enhancement",
        "since": "2.0"
      },
      {
        "section": "¬ß6.3",
        "description": "Complete attenuation function specification",
        "type": "fix",
        "since": "2.0"
      },
      {
        "section": "¬ß3.4",
        "description": "Soft/hard dependency cascade boundary rules",
        "type": "enhancement",
        "since": "2.0"
      },
      {
        "section": "¬ß13",
        "description": "Concurrency semantics (CRDT-based)",
        "type": "new",
        "since": "2.0"
      },
      {
        "section": "¬ß14",
        "description": "Binding verification lifecycle",
        "type": "new",
        "since": "2.0"
      },
      {
        "section": "¬ß15",
        "description": "Formal Properties and Theorems (consolidates v1.0 ¬ß10 with proofs)",
        "type": "enhancement",
        "since": "2.0"
      },
      {
        "section": "¬ß16",
        "description": "Schema evolution: compatibility rules, migration operations",
        "type": "new",
        "since": "2.4"
      },
      {
        "section": "¬ß25",
        "description": "Bibliography citation corrections (3 erroneous papers removed)",
        "type": "fix",
        "since": "2.4"
      },
      {
        "section": "¬ß26",
        "description": "DO-178C/ISO 26262 coverage matrix corrections",
        "type": "fix",
        "since": "2.4"
      },
      {
        "section": "¬ß27",
        "description": "STPA/FMEA integration framework",
        "type": "new",
        "since": "2.4"
      },
      {
        "section": "¬ß28",
        "description": "Formal attenuation properties (monotonicity, BIBO stability)",
        "type": "new",
        "since": "2.4"
      },
      {
        "section": "¬ß29",
        "description": "Cross-standard traceability (DO-178C ‚Üî ISO 26262)",
        "type": "new",
        "since": "2.4"
      },
      {
        "section": "¬ß30",
        "description": "LSL-style tier boundary semantics",
        "type": "new",
        "since": "2.4"
      },
      {
        "section": "manifest",
        "description": "Structural reorganization: 6 logical parts, bibliography moved to end, ¬ß10 deprecated",
        "type": "enhancement",
        "since": "2.4.1"
      }
    ],
    "domains": [
      "Software Systems",
      "Organizations",
      "Manufacturing",
      "Healthcare",
      "Legal",
      "Enterprise Architecture"
    ]
  },
  "sections": [
    {
      "id": "sec-01",
      "number": "1",
      "title": "Foundations",
      "defs": [],
      "content": [
        {
          "type": "heading",
          "level": 2,
          "text": "How to Read This Document"
        },
        {
          "type": "paragraph",
          "text": "This specification is organized in six logical parts across 30 sections. The recommended reading path depends on your role:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "**Formal Semanticists**",
              "definition": "Read sequentially: ¬ß1‚Äì10 (Foundations) ‚Üí ¬ß10‚Äì22 (Formal Theory) ‚Üí ¬ß25 (Attenuation Properties)"
            },
            {
              "term": "**Language Implementers**",
              "definition": "Read: ¬ß1‚Äì6 (Type System) ‚Üí ¬ß7 (Operations) ‚Üí ¬ß11 (Reference Implementation) ‚Üí ¬ß18 (Language Checklists)"
            },
            {
              "term": "**Safety/Certification Engineers**",
              "definition": "Read: ¬ß1‚Äì4 (Foundations, Guarantees) ‚Üí ¬ß15‚Äì16 (Certification) ‚Üí ¬ß23‚Äì26 (Coverage, STPA, Attenuation, Traceability)"
            },
            {
              "term": "**Integration Engineers**",
              "definition": "Read: ¬ß2 (Abstract Syntax) ‚Üí ¬ß8‚Äì9 (Domain Profiles, Extensions) ‚Üí ¬ß12‚Äì14 (Concurrency, Binding, Schema Evolution)"
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Document Structure at a Glance"
        },
        {
          "type": "paragraph",
          "text": "**PART I: Foundations (¬ß1‚Äì6)**\nCore type system, abstract syntax, well-formedness, guarantees, and inference rules.\n\n**PART II: Operations (¬ß7‚Äì9)**\nQuery, modification, domain profiles, and extensibility.\n\n**PART III: Formal Theory (¬ß10‚Äì27)**\nTheorems, proofs, concurrency semantics, certification, and advanced properties.\n\n**APPENDICES (¬ß28‚Äì30)**\nSummary, glossary, and bibliography."
        },
        {
          "type": "paragraph",
          "text": "**Key Dependencies**\nSections 1‚Äì2 must be read before any others. Section 5 (Type System) is required for ¬ß6‚Äì7. Section 10 (Formal Properties) provides theoretical grounding for all subsequent sections."
        },
        {
          "type": "heading",
          "level": 2,
          "text": "¬ß1.1 PRIMITIVE SETS"
        },
        {
          "type": "paragraph",
          "text": "Let the following primitive sets be given:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "ID",
              "definition": "A countably infinite set of identifiers"
            },
            {
              "term": "NAME",
              "definition": "A countably infinite set of names (strings)"
            },
            {
              "term": "VALUE",
              "definition": "The universal value domain (JSON-compatible)"
            },
            {
              "term": "TIME",
              "definition": "The set of timestamps (ISO 8601)"
            },
            {
              "term": "‚Ñï",
              "definition": "Natural numbers"
            },
            {
              "term": "‚Ñ§",
              "definition": "Integers"
            },
            {
              "term": "‚Ñù",
              "definition": "Real numbers"
            },
            {
              "term": "ùîπ",
              "definition": "Booleans {‚ä§, ‚ä•}"
            },
            {
              "term": "ACTOR",
              "definition": "A countably infinite set of actor identifiers [v2.0]"
            },
            {
              "term": "CLOCK",
              "definition": "Vector clocks for causality tracking [v2.0]"
            }
          ]
        },
        {
          "type": "heading",
          "level": 2,
          "text": "¬ß1.2 DERIVED SETS"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "ID*",
              "definition": "ID ‚à™ {Œµ} - Identifiers with null"
            },
            {
              "term": "P(X)",
              "definition": "Power set of X"
            },
            {
              "term": "X √ó Y",
              "definition": "Cartesian product"
            },
            {
              "term": "X ‚Üí Y",
              "definition": "Total functions from X to Y"
            },
            {
              "term": "X ‚áÄ Y",
              "definition": "Partial functions from X to Y"
            },
            {
              "term": "X*",
              "definition": "Finite sequences over X"
            },
            {
              "term": "X‚Å∫",
              "definition": "Non-empty finite sequences over X"
            },
            {
              "term": "Multiset(X)",
              "definition": "Multisets over X [v2.0]"
            }
          ]
        },
        {
          "type": "heading",
          "level": 2,
          "text": "¬ß1.3 NOTATION CONVENTIONS"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "e, e‚ÇÅ, e‚ÇÇ, ...",
              "definition": "Elements"
            },
            {
              "term": "l, l‚ÇÅ, l‚ÇÇ, ...",
              "definition": "Layers"
            },
            {
              "term": "d, d‚ÇÅ, d‚ÇÇ, ...",
              "definition": "Dependencies"
            },
            {
              "term": "c, c‚ÇÅ, c‚ÇÇ, ...",
              "definition": "Constraints"
            },
            {
              "term": "b, b‚ÇÅ, b‚ÇÇ, ...",
              "definition": "Bindings"
            },
            {
              "term": "r, r‚ÇÅ, r‚ÇÇ, ...",
              "definition": "Cascade rules"
            },
            {
              "term": "S, S‚ÇÅ, S‚ÇÇ, ...",
              "definition": "Specifications"
            },
            {
              "term": "Œì, Œî, Œò",
              "definition": "Contexts (sets of judgments)"
            },
            {
              "term": "œÑ, œÉ, œÅ",
              "definition": "Types"
            },
            {
              "term": "œÄ, œÜ, œà",
              "definition": "Predicates"
            },
            {
              "term": "Œ±, Œ≤",
              "definition": "Actor identifiers [v2.0]"
            },
            {
              "term": "vc, vc‚ÇÅ, vc‚ÇÇ",
              "definition": "Vector clocks [v2.0]"
            }
          ]
        },
        {
          "type": "heading",
          "level": 2,
          "text": "¬ß1.4 THE STRATUM KERNEL (K0)"
        },
        {
          "type": "paragraph",
          "text": "**Purpose**: The STRATUM Kernel is the irreducible core of the specification‚Äîthe minimum set of definitions required for K0 conformance. This section provides a self-contained reading guide for implementers who need only the essential framework without certification, concurrency, or advanced features."
        },
        {
          "type": "admonition",
          "level": "note",
          "text": "**Conformance Level K0 (Kernel-Conformant)**: Implementers reading ONLY the Kernel sections can achieve basic STRATUM conformance. Higher conformance levels (K1: Certified-Aware, K2: Regulated-Pipeline, K3: Live-Graph) require additional sections per ¬ß0.4 [v2.5]."
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Kernel Components"
        },
        {
          "type": "paragraph",
          "text": "The Kernel consists of six essential subsystems:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "**1. Data Structures** (¬ß2.1-2.3)",
              "definition": "Element, Layer, Dependency ‚Äî the core abstract syntax tree. Read: Definition 2.1 (Element), Definition 2.6 (Layer), Definition 2.11 (Dependency), Definition 2.8 (DEPTYPE enumeration)."
            },
            {
              "term": "**2. Constraints** (¬ß2.4)",
              "definition": "QF_LIA + QF_LRA + QF_UF constraint language per v2.4.4. Read: Definition 2.12 (Predicate Language), Definition 2.16 (Constraint), Theorem 2.1 (Decidability). Note: SMT-LIB 2.6 standard required for conformance."
            },
            {
              "term": "**3. Well-Formedness** (¬ß3)",
              "definition": "Structural invariants that all specifications must satisfy. Read: All WF-rules including WF-ID, WF-LAYER, WF-ACYCLIC-HARD, WF-SOFT-CYCLE-BOUNDED, WF-CASCADE-TERMINATION (added v2.4.4)."
            },
            {
              "term": "**4. Six Guarantees** (¬ß4.1-4.6)",
              "definition": "G1 (Traceability), G2 (Completeness), G3 (Consistency), G4 (Groundedness), G5 (Determinism), G6 (Coherence). These are the semantic properties that define a Valid specification. G7 (Explainability) is K1, not K0."
            },
            {
              "term": "**5. Inference Rules** (¬ß6)",
              "definition": "Cascade computation (CASCADE-1, CASCADE-N, CASCADE-ATT), constraint satisfaction (CONSTR-SAT), trace computation (TRACE-ROOT, TRACE-STEP). These define the operational semantics."
            },
            {
              "term": "**6. Core Operations** (¬ß7.1-7.3)",
              "definition": "validate(S) ‚Üí violations, trace(e) ‚Üí path, impact(S, Œ¥) ‚Üí affected elements. These are the three required Kernel operations. Note: validateIncremental (¬ß7.1.1) is K3, not K0."
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Kernel Properties"
        },
        {
          "type": "paragraph",
          "text": "All Kernel operations share three essential properties:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "**Pure**",
              "definition": "All Kernel functions are deterministic total functions with no side effects. No I/O, no randomness, no wall-clock time dependencies. Given the same input, always produce the same output."
            },
            {
              "term": "**Decidable**",
              "definition": "All Kernel judgments terminate with definite yes/no answers. No \"unknown\" or \"timeout\" results. Well-formedness checking is O(|E| + |D| + |L|¬≤). Constraint validation is decidable via SMT solving (NP-complete, but terminates)."
            },
            {
              "term": "**Compositional**",
              "definition": "Kernel(S‚ÇÅ ‚äï S‚ÇÇ) = Kernel(S‚ÇÅ) ‚äï Kernel(S‚ÇÇ). Merging two specifications preserves all Kernel properties. This follows from the CRDT-based merge semantics (¬ß12) but does not require understanding CRDTs for K0 conformance."
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "What is NOT in the Kernel"
        },
        {
          "type": "paragraph",
          "text": "The following features are EXTENSIONS, not Kernel requirements:"
        },
        {
          "type": "list",
          "items": [
            "**Concurrency (¬ß12-13)**: CRDTs, vector clocks, conflict resolution. Optional for single-user tools.",
            "**Certification (¬ß15-18, ¬ß23-29)**: RTM, DO-178C/ISO 26262 mappings, STPA/FMEA. Only required for K2+ conformance.",
            "**Advanced Operations (¬ß7.4, ¬ß8-9)**: Artifact adapters, domain profiles, extension mechanisms. Useful but not essential.",
            "**Mechanized Proofs (¬ß17, ¬ß19-22)**: TLA+, Coq, Lean templates. Helpful for verification but not required for implementation.",
            "**G7 Explainability (¬ß4.8)**: Unsat core generation. This is K1 (Certified-Aware), not K0."
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Kernel-Only Reading Path"
        },
        {
          "type": "paragraph",
          "text": "For K0 conformance, read in this order:"
        },
        {
          "type": "list",
          "items": [
            "¬ß1.1-1.3: Primitive sets, notation (5 minutes)",
            "¬ß1.4: This section (10 minutes)",
            "¬ß2.1-2.4: Element, Layer, Dependency, Constraint (30 minutes)",
            "¬ß3: Well-formedness conditions (15 minutes)",
            "¬ß4.1-4.6: The Six Guarantees G1-G6 (25 minutes)",
            "¬ß6: Inference rules for cascade, trace, constraints (20 minutes)",
            "¬ß7.1-7.3: validate(), trace(), impact() operations (15 minutes)",
            "¬ß10.1-10.3: Soundness, decidability, cascade termination theorems (10 minutes)"
          ]
        },
        {
          "type": "paragraph",
          "text": "**Total: ~2 hours** to understand the complete Kernel. Compare this to 30 sections (8-10 hours for full specification)."
        },
        {
          "type": "admonition",
          "level": "important",
          "text": "**Kernel Boundary Enforcement**: Some sections are explicitly marked **non-Kernel**. Artifact Adapters (¬ß7.4) introduce `effectful: true` to mark I/O-performing components that violate Kernel purity. These adapters emit Operation lists that the Kernel consumes deterministically, maintaining the pure/effectful boundary."
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Reference Implementation Checklist"
        },
        {
          "type": "paragraph",
          "text": "To claim K0 conformance, your implementation must:"
        },
        {
          "type": "list",
          "items": [
            "‚úì Implement data structures: Specification, Element, Layer, Dependency, Constraint, Binding, CascadeRule",
            "‚úì Implement constraint language: QF_LIA + QF_LRA + QF_UF (via SMT solver like Z3, CVC5, or Yices)",
            "‚úì Implement all WF-rules from ¬ß3 (including v2.4.4 additions: WF-SOFT-CYCLE-BOUNDED, WF-CASCADE-TERMINATION)",
            "‚úì Implement guarantee checkers for G1-G6 (¬ß4.1-4.6)",
            "‚úì Implement cascade computation per CASCADE-1, CASCADE-N rules (¬ß6.3)",
            "‚úì Implement validate(S), trace(e), impact(S, Œ¥) operations (¬ß7.1-7.3)",
            "‚úì Pass Kernel test suite (if available from reference implementation)",
            "‚úì Demonstrate purity: All operations return same output for same input",
            "‚úì Demonstrate decidability: All operations terminate (no infinite loops)"
          ]
        },
        {
          "type": "paragraph",
          "text": "**Optional but Recommended**: Implement Zod schemas (¬ß11) for runtime validation, though note the schema drift warning from v2.4.4 (Zod schemas are v1.0 and lack v2.0+ fields like cascade_boundary, priority, actor, clock)."
        }
      ]
    },
    {
      "id": "sec-01-demo",
      "number": "1.5",
      "title": "STRATUM in Action: Requirement Change Impact",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "**Purpose**: This scenario demonstrates the complete STRATUM workflow from requirement change through impact analysis, validation, policy evaluation, and certification artifact generation. It showcases v2.4.4 dependency direction clarification and v2.5 additions (G7 Explainability, Policy System)."
        },
        {
          "type": "admonition",
          "level": "note",
          "text": "**Context**: Automotive brake-by-wire system (ASIL-D per ISO 26262), in production for 2 years. Safety engineer modifies a timing requirement. Total workflow time: **4 minutes** from trigger to signed certification package."
        },
        {
          "type": "heading",
          "level": 3,
          "text": "1. TRIGGER: Requirement Modification"
        },
        {
          "type": "code",
          "language": "typescript",
          "lines": [
            "// Safety engineer alice@example.com modifies REQ-042",
            "const change: Change = {",
            "  element: 'REQ-042',",
            "  changeType: 'update',",
            "  actor: 'alice@example.com',",
            "  timestamp: '2025-01-12T14:32:07Z',",
            "  description: 'Tighten braking response time',",
            "  diff: {",
            "    properties: {",
            "      maxResponseTime: { old: '150ms', new: '100ms' }",
            "    }",
            "  }",
            "};"
          ]
        },
        {
          "type": "paragraph",
          "text": "**Element Context**: REQ-042 is in the **motivation tier** (layer=safety-requirements, type=TimingRequirement, integrityLevel=ASIL_D)."
        },
        {
          "type": "heading",
          "level": 3,
          "text": "2. IMPACT ANALYSIS (<1 second)"
        },
        {
          "type": "paragraph",
          "text": "STRATUM's `impact(S, change)` operation traverses dependencies using the polarity table (v2.5 ¬ß2.3). Dependency direction per v2.4.4 ¬ß2.3: structural arrows point concrete ‚Üí abstract, but CASCADE walks from changed element along dep arrows."
        },
        {
          "type": "code",
          "language": "typescript",
          "lines": [
            "// Impact computation uses polarity-aware cascade",
            "const impacted = impact(specification, change);",
            "",
            "// Results (by dependency type per v2.5 policy table):",
            "// realizes (backward, attenuate): 3 design elements in logical tier",
            "// traces_to (backward, block): 7 code modules identified (no cascade)",
            "// validates (both, block): 12 test cases flagged (bidirectional awareness)",
            "// constrains (backward, attenuate): 2 safety constraints re-evaluated"
          ]
        },
        {
          "type": "paragraph",
          "text": "**Dependency Traversal** (v2.4.4 semantics):"
        },
        {
          "type": "list",
          "items": [
            "`realizes`: Design-001 ‚Üí REQ-042 (concrete depends on abstract). If REQ-042 changes, CASCADE finds deps where `d.src=REQ-042` (none of type realizes), so no auto-cascade. But `realizes` has **backward** impact per v2.5: when requirement changes, designs depending on it need review (attenuated).",
            "`traces_to`: Module-017 ‚Üí REQ-042 (impl traces to req). This is upward structural dep (G6 exception). CASCADE behavior: **block** (no propagation, just flagging).",
            "`validates`: Test-089 validates REQ-042 (bidirectional). Both elements flagged for review.",
            "`constrains`: SafetyConstraint-005 constrains REQ-042. Constraint needs re-checking."
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "3. ATTENUATION CALCULATION"
        },
        {
          "type": "paragraph",
          "text": "Per ¬ß6.3 CASCADE-ATT and v2.5 policy table, impact severity attenuates across tier boundaries:"
        },
        {
          "type": "code",
          "lines": [
            "// Attenuation function: Œ≥ = 2^(-tier_diff)",
            "motivation tier:  100% impact (source tier)",
            "logical tier:      50% impact (Œ≥ = 2^-1 = 0.5)",
            "realization tier:  25% impact (Œ≥ = 2^-2 = 0.25)",
            "grounding tier:    12.5% impact (Œ≥ = 2^-3 = 0.125)",
            "",
            "// Severity mapping:",
            "attenuate(breaking) = degraded",
            "attenuate(degraded) = cosmetic",
            "attenuate(cosmetic) = none"
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "4. VALIDATION WITH G7 EXPLAINABILITY"
        },
        {
          "type": "paragraph",
          "text": "STRATUM v2.5 adds **G7 (Explainability)** with irreducible unsat cores per [Z3-Cores]. Each violation includes a subset-minimal explanation."
        },
        {
          "type": "code",
          "language": "typescript",
          "lines": [
            "const violations = validate(specification);",
            "",
            "// G2 (Completeness) VIOLATED",
            "{",
            "  violatedGuarantee: 'G2',",
            "  unsatCore: ['C-TIMING-COVERAGE', 'C-TEST-BOUNDS'],  // Irreducible!",
            "  unsatCoreProperty: 'irreducible',  // Per Theorem 10.12",
            "  blameChain: [",
            "    { operationId: 'OP-4521', actor: 'alice@example.com',",
            "      clock: {alice: 1523}, description: 'Updated REQ-042 maxResponseTime' }",
            "  ],",
            "  humanReadable: 'Test case TC-089 asserts ‚â§150ms, insufficient for new ‚â§100ms requirement. Constraint C-TEST-BOUNDS requires all timing tests to match requirements.',",
            "  suggestedFix: 'Update TC-089 assertion to assert(responseTime <= 100ms)'",
            "}",
            "",
            "// G3 (Consistency) VIOLATED",
            "{",
            "  violatedGuarantee: 'G3',",
            "  unsatCore: ['C-MODULE-TIMING'],  // Single-constraint core",
            "  blameChain: [{ operationId: 'OP-4521', ... }],",
            "  humanReadable: 'Module M-017 specifies 120ms processing time, conflicts with REQ-042 (100ms). Constraint C-MODULE-TIMING requires module timing ‚â§ requirement timing.',",
            "  suggestedFix: 'Reduce M-017 processing time to ‚â§95ms (allowing 5ms margin)'",
            "}",
            "",
            "// G4 (Groundedness) ‚úì OK (all grounding-tier elements have bindings)"
          ]
        },
        {
          "type": "admonition",
          "level": "important",
          "text": "**G7 Guarantee** (v2.5 ¬ß4.8): Every unsat core is **irreducible** (subset-minimal). This means: ‚àÄc ‚àà core: SAT(core \\ {c}). Deleting any single constraint makes the core satisfiable, proving minimality. This is NOT the same as minimum-size (cardinality-minimal), which is NP-hard. Z3's deletion-based MUS extraction provides irreducibility in O(n √ó SMT) where n = |core|."
        },
        {
          "type": "heading",
          "level": 3,
          "text": "5. POLICY EVALUATION"
        },
        {
          "type": "paragraph",
          "text": "STRATUM v2.5 adds **Policy System** (¬ß2.8, ¬ß7.5) for automated remediation workflows. Policies trigger based on violation characteristics."
        },
        {
          "type": "code",
          "language": "typescript",
          "lines": [
            "const triggeredPolicies = evaluatePolicies(specification, violations);",
            "",
            "// POL-ASIL-D-REVIEW triggered (integrityLevel = ASIL_D)",
            "{",
            "  policyId: 'POL-ASIL-D-REVIEW',",
            "  appliesTo: { integrityLevels: ['ASIL_D'] },",
            "  actions: {",
            "    requiredReviewers: { role: 'safety-engineer', count: 2,",
            "                         escalationTimeout: '48h' },",
            "    requiredEvidenceTypes: ['static_analysis', 'manual_review'],",
            "    minimumEvidenceCount: 2,",
            "    blockingBehavior: 'block_merge'",
            "  },",
            "  status: 'BLOCKING'  // Merge to main branch blocked until satisfied",
            "}",
            "",
            "// POL-G7-EXPLAIN triggered (any violation with G7 enabled)",
            "{",
            "  policyId: 'POL-G7-EXPLAIN',",
            "  appliesTo: { guarantees: ['G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7'] },",
            "  actions: {",
            "    suggestedFixes: [...],  // From G7 explanations",
            "    blockingBehavior: 'warn_only'",
            "  }",
            "}"
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "6. GENERATED ARTIFACTS"
        },
        {
          "type": "paragraph",
          "text": "STRATUM automatically generates certification artifacts per ¬ß15-18:"
        },
        {
          "type": "list",
          "items": [
            "**RTM Delta** (¬ß15.1): 3 rows updated (REQ-042 ‚Üí Design-001, Module-017, Test-089), 2 rows flagged as incomplete",
            "**GSN Delta** (v2.5 ¬ß15.6): G-TIMING argument node needs update (new sub-goal for 100ms verification)",
            "**Checklist** (¬ß18): DAL-B checklist (12 DO-178C objectives apply to this change)",
            "**CI Trigger**: Run test suite subset: TC-089, TC-091, TC-103 (timing-related tests)"
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "7. RESOLUTION WORKFLOW"
        },
        {
          "type": "code",
          "language": "typescript",
          "lines": [
            "// Developer applies suggested fixes from G7",
            "1. Update M-017: processingTime = '95ms'  // Was 120ms",
            "2. Update TC-089: assert(responseTime <= 100)  // Was <= 150",
            "",
            "// Re-validate",
            "const violations2 = validate(specification);",
            "// Result: All guarantees ‚úì (G1-G7 satisfied)",
            "",
            "// Complete reviews (per POL-ASIL-D-REVIEW)",
            "addEvidence({",
            "  type: 'manual_review',",
            "  reviewer: 'bob@example.com',",
            "  timestamp: '2025-01-12T14:35:12Z',",
            "  verdict: 'approved',",
            "  comments: 'Timing analysis confirms 95ms + 5ms margin is sufficient'",
            "});",
            "addEvidence({",
            "  type: 'manual_review',",
            "  reviewer: 'carol@example.com',",
            "  timestamp: '2025-01-12T14:36:07Z',",
            "  verdict: 'approved'",
            "});"
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "8. CERTIFICATION PACKAGE EXPORT"
        },
        {
          "type": "paragraph",
          "text": "Final step: Export tamper-evident certification package per v2.5 ¬ß13.4 (Cryptographic Evidence Attestation) and ¬ß11.2 (SEF - STRATUM Exchange Format)."
        },
        {
          "type": "code",
          "language": "typescript",
          "lines": [
            "const certPackage = exportCertificationPackage(specification);",
            "",
            "// Package contents (SEF + crypto attestation)",
            "{",
            "  format: 'application/vnd.stratum+json',",
            "  specification: { ...spec },  // Canonical per RFC-8785",
            "  evidenceChain: [",
            "    // 47 evidence records with hash chain",
            "    { id: 'E-001', contentHash: 'sha256:a3f2c8...',",
            "      previousHash: null },",
            "    { id: 'E-002', contentHash: 'sha256:7d4e1b...',",
            "      previousHash: 'sha256:a3f2c8...' },",
            "    // ... 45 more ...",
            "    { id: 'E-047', contentHash: 'sha256:9c1fa2...',",
            "      previousHash: 'sha256:2b8d3e...' }",
            "  ],",
            "  verification: {",
            "    chainIntegrity: 'verified',  // All hashes match",
            "    temporalOrdering: 'verified',  // Vector clocks consistent",
            "    relevanceBinding: 'verified',  // All ops in spec.history",
            "    signatures: 'verified'  // All JWS signatures valid",
            "  },",
            "  contentHash: 'sha256:f8a9b3c7e2d1...',  // Semantic hash",
            "  signature: {",
            "    alg: 'ES256',  // ECDSA with P-256 and SHA-256",
            "    kid: 'release-authority@example.com',",
            "    sig: '...'  // JWS signature per RFC-7515",
            "  }",
            "}"
          ]
        },
        {
          "type": "admonition",
          "level": "note",
          "text": "**Threat Model** (v2.5 ¬ß13.4.1): The hash chain defends against post-hoc tampering, evidence replay, and out-of-order insertion. It does NOT defend against compromised signing keys (requires external PKI) or collusion of all actors (requires Byzantine fault tolerance). These are explicitly out-of-scope per v2.5 design."
        },
        {
          "type": "heading",
          "level": 3,
          "text": "WORKFLOW SUMMARY"
        },
        {
          "type": "code",
          "lines": [
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            "TOTAL TIME: 4 minutes (trigger ‚Üí certified package)",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            "",
            "00:00  Requirement change triggered (alice@example.com)",
            "00:01  Impact analysis complete (22 elements affected)",
            "00:01  Validation complete (2 violations: G2, G3)",
            "00:01  G7 explanations generated (2 irreducible cores)",
            "00:01  Policies evaluated (POL-ASIL-D-REVIEW blocking)",
            "00:02  Suggested fixes applied (M-017, TC-089 updated)",
            "00:02  Re-validation complete (all guarantees ‚úì)",
            "02:00  Review 1 complete (bob@example.com approved)",
            "03:00  Review 2 complete (carol@example.com approved)",
            "03:30  Certification artifacts generated (RTM, GSN, checklist)",
            "04:00  Package signed and exported (47 evidence records)",
            "",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Key Capabilities Demonstrated"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "**Dependency Direction Semantics** (v2.4.4 ¬ß2.3)",
              "definition": "Structural direction (concrete ‚Üí abstract) vs impact flow (CASCADE walks from changed element). realizes has backward impact despite forward structural arrow."
            },
            {
              "term": "**Polarity-Aware Cascade** (v2.5 ¬ß2.3)",
              "definition": "Normative policy table determines cascadeBehavior: realizes=attenuate, traces_to=block, validates=block, constrains=attenuate."
            },
            {
              "term": "**G7 Explainability** (v2.5 ¬ß4.8)",
              "definition": "Irreducible unsat cores (subset-minimal, not cardinality-minimal). Every constraint in core is essential. Deletion-based MUS extraction per [Z3-Cores]."
            },
            {
              "term": "**Policy System** (v2.5 ¬ß2.8, ¬ß7.5)",
              "definition": "Declarative remediation workflows. Policies trigger on integrityLevel, guarantee violations, severity. Actions include required reviewers, evidence types, blocking behavior."
            },
            {
              "term": "**Cryptographic Attestation** (v2.5 ¬ß13.4)",
              "definition": "Tamper-evident evidence chains with SHA-256 hash linking, JWS signatures per RFC-7515, vector clock temporal ordering. Threat model explicitly documented."
            },
            {
              "term": "**SEF Interchange** (v2.5 ¬ß11.2)",
              "definition": "STRATUM Exchange Format with canonical ordering per RFC-8785, semantic hashing, media types (JSON, CBOR, Gzip)."
            }
          ]
        },
        {
          "type": "paragraph",
          "text": "**Conclusion**: This 4-minute workflow demonstrates how STRATUM v2.5 integrates v2.4.4's foundational fixes (dependency direction, WF-rules, SMT-LIB precision) with v2.5's operational capabilities (G7, policies, crypto attestation) to deliver end-to-end traceability from requirement change to certified release package."
        }
      ]
    },
    {
      "id": "sec-02",
      "number": "2",
      "title": "Abstract Syntax",
      "defs": [],
      "children": [
        {
          "id": "sec-02-1",
          "number": "2.1",
          "title": "Element",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "An Element is the atomic unit of specification."
            },
            {
              "type": "definition",
              "label": "Definition 2.1 (Element)",
              "text": "e ::= ‚ü®id, œÑ, l, œÄ, Œº‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "id ‚àà ID",
                  "definition": "Unique identifier"
                },
                {
                  "term": "œÑ ‚àà TYPE",
                  "definition": "Element type (from layer's type vocabulary)"
                },
                {
                  "term": "l ‚àà ID",
                  "definition": "Layer identifier (membership) [IMMUTABLE - see ¬ß5.3] ‚üπ Forward reference explained in Type System section"
                },
                {
                  "term": "œÄ : NAME ‚Üí VALUE",
                  "definition": "Properties (partial function)"
                },
                {
                  "term": "Œº : METADATA",
                  "definition": "Metadata record"
                }
              ]
            },
            {
              "type": "admonition",
              "level": "critical",
              "text": "CRITICAL INVARIANT [v2.0]: The layer component 'l' is IMMUTABLE after creation. This enables covariant subtyping in ¬ß5.3 while maintaining type soundness. To change an element's layer, delete and recreate with new layer assignment."
            },
            {
              "type": "definition",
              "label": "Definition 2.2 (Metadata)",
              "text": "METADATA = ‚ü®created: TIME, updated: TIME, version: VersionVector, status: STATUS, actor: ACTOR, clock: CLOCK‚ü©"
            },
            {
              "type": "paragraph",
              "text": "STATUS = {draft, active, deprecated, archived}"
            },
            {
              "type": "definition",
              "label": "Definition 2.3 (Version Vector) [v2.0]",
              "text": "VersionVector = ACTOR ‚Üí ‚Ñï"
            },
            {
              "type": "paragraph",
              "text": "Operations:"
            },
            {
              "type": "code",
              "lines": [
                "vv‚ÇÅ ‚â§ vv‚ÇÇ  iff  ‚àÄŒ±. vv‚ÇÅ(Œ±) ‚â§ vv‚ÇÇ(Œ±)     -- partial order",
                "vv‚ÇÅ ‚äî vv‚ÇÇ  =  ŒªŒ±. max(vv‚ÇÅ(Œ±), vv‚ÇÇ(Œ±))   -- join (supremum)",
                "inc(vv, Œ±) =  vv[Œ± ‚Ü¶ vv(Œ±) + 1]          -- increment"
              ]
            },
            {
              "type": "paragraph",
              "text": "Notation: e.id, e.œÑ, e.l, e.œÄ, e.Œº for projections"
            }
          ]
        },
        {
          "id": "sec-02-2",
          "number": "2.2",
          "title": "Layer",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "A Layer is a level of abstraction containing elements."
            },
            {
              "type": "definition",
              "label": "Definition 2.4 (Tier)",
              "text": "TIER = {motivation, logical, realization, grounding}"
            },
            {
              "type": "paragraph",
              "text": "with total order: motivation < logical < realization < grounding"
            },
            {
              "type": "definition",
              "label": "Definition 2.5 (Tier Semantics) [v2.0]",
              "text": "The tier ordering represents REFINEMENT direction:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "motivation",
                  "definition": "WHY - goals, values, and rationale"
                },
                {
                  "term": "logical",
                  "definition": "WHAT - abstract design and contracts"
                },
                {
                  "term": "realization",
                  "definition": "HOW - concrete implementation approach"
                },
                {
                  "term": "grounding",
                  "definition": "WHERE - physical artifacts and bindings"
                }
              ]
            },
            {
              "type": "paragraph",
              "text": "Refinement: tier(l‚ÇÅ) < tier(l‚ÇÇ) means l‚ÇÇ REFINES l‚ÇÅ (l‚ÇÇ provides more concrete details implementing l‚ÇÅ's abstractions). This is analogous to MDA's CIM ‚Üí PIM ‚Üí PSM progression. **Dependency arrows point FROM concrete TO abstract** (e.g., realization ‚Üí logical, meaning concrete elements DEPEND ON abstract specifications). This is enforced by Coherence (G6): pos(src) ‚â• pos(tgt). See ¬ß2.3 for dependency direction vs impact flow clarification."
            },
            {
              "type": "diagram",
              "format": "ascii",
              "content": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                                                                     ‚îÇ\n‚îÇ                         TIER FLOW DIAGRAM                           ‚îÇ\n‚îÇ                                                                     ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ  MOTIVATION (WHY)                                           ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îÇ  Goal   ‚îÇ  ‚îÇ  Value  ‚îÇ  ‚îÇ  Metric ‚îÇ                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ          ‚îÇ traces_to ‚ñ≤‚îÇ            ‚îÇ  ‚óÑ‚îÄ‚îÄ UPWARD (certification)   ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ  LOGICAL (WHAT)    ‚îÇ            ‚îÇ                           ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îÇComponent‚îÇ  ‚îÇ Contract‚îÇ  ‚îÇ   API   ‚îÇ                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ          ‚ñº realizes   ‚ñº requires   ‚ñº  ‚óÑ‚îÄ‚îÄ DOWNWARD (refinement)    ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ  REALIZATION (HOW) ‚îÇ            ‚îÇ                           ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îÇ  Module ‚îÇ  ‚îÇ  Config ‚îÇ  ‚îÇ Pipeline‚îÇ                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ          ‚ñº realizes   ‚ñº            ‚ñº                               ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ  GROUNDING (WHERE) ‚îÇ            ‚îÇ                           ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îÇ  File   ‚îÇ  ‚îÇ Symbol  ‚îÇ  ‚îÇ  Line   ‚îÇ  ‚Üê‚îÄ‚îÄ Bindings        ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ                                                                     ‚îÇ\n‚îÇ  LEGEND:                                                            ‚îÇ\n‚îÇ    ‚ñº realizes/requires  = Refinement (downward, cascade attenuates)‚îÇ\n‚îÇ    ‚ñ≤ traces_to          = Certification (upward, cascade blocked)  ‚îÇ\n‚îÇ                                                                     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
              "caption": "Figure 2.1: Tier flow showing the asymmetry between dependency direction (realizes/requires go downward) and traces_to (upward for certification). Impact cascades follow dependency arrows with attenuation across tier boundaries.",
              "alt": "Diagram showing four tiers (Motivation, Logical, Realization, Grounding) with downward refinement dependencies (realizes/requires) and upward certification dependencies (traces_to). Cascade attenuation occurs on downward propagation."
            },
            {
              "type": "definition",
              "label": "Definition 2.6 (Layer)",
              "text": "l ::= ‚ü®id, name, tier, order, Q, T, deps‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "id ‚àà ID",
                  "definition": "Unique identifier"
                },
                {
                  "term": "name ‚àà NAME",
                  "definition": "Human-readable name"
                },
                {
                  "term": "tier ‚àà TIER",
                  "definition": "Which tier this layer belongs to"
                },
                {
                  "term": "order ‚àà ‚Ñï",
                  "definition": "Position within tier (0 = most abstract)"
                },
                {
                  "term": "Q ‚àà NAME",
                  "definition": "The question this layer answers"
                },
                {
                  "term": "T ‚äÜ TYPE",
                  "definition": "Vocabulary of element types"
                },
                {
                  "term": "deps ‚äÜ ID",
                  "definition": "Layer dependencies (required layers)"
                }
              ]
            },
            {
              "type": "definition",
              "label": "Definition 2.7 (Layer Position)",
              "text": "pos(l) = ‚ü®l.tier, l.order‚ü©"
            },
            {
              "type": "paragraph",
              "text": "Ordering: pos(l‚ÇÅ) < pos(l‚ÇÇ) iff l‚ÇÅ.tier < l‚ÇÇ.tier ‚à® (l‚ÇÅ.tier = l‚ÇÇ.tier ‚àß l‚ÇÅ.order < l‚ÇÇ.order)"
            }
          ]
        },
        {
          "id": "sec-02-3",
          "number": "2.3",
          "title": "Dependency",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "A Dependency is a directed relationship between elements."
            },
            {
              "type": "definition",
              "label": "Definition 2.8 (Dependency Type)",
              "text": "DEPTYPE = {realizes, requires, produces, consumes, constrains, validates, traces_to}"
            },
            {
              "type": "definition",
              "label": "Definition 2.9 (Strength)",
              "text": "STRENGTH = {hard, soft}"
            },
            {
              "type": "paragraph",
              "text": "Semantics:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "hard",
                  "definition": "Breaking this dependency invalidates the specification"
                },
                {
                  "term": "soft",
                  "definition": "Breaking this dependency degrades but doesn't invalidate"
                }
              ]
            },
            {
              "type": "definition",
              "label": "Definition 2.10 (Cardinality)",
              "text": "CARDINALITY = {one_to_one, one_to_many, many_to_one, many_to_many}"
            },
            {
              "type": "definition",
              "label": "Definition 2.11 (Dependency)",
              "text": "d ::= ‚ü®id, src, tgt, Œ¥, œÉ, Œ∫, cascade_boundary‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "id ‚àà ID",
                  "definition": "Unique identifier"
                },
                {
                  "term": "src ‚àà ID √ó ID",
                  "definition": "Source (element_id, layer_id)"
                },
                {
                  "term": "tgt ‚àà ID √ó ID",
                  "definition": "Target (element_id, layer_id)"
                },
                {
                  "term": "Œ¥ ‚àà DEPTYPE",
                  "definition": "Dependency type"
                },
                {
                  "term": "œÉ ‚àà STRENGTH",
                  "definition": "Hard or soft"
                },
                {
                  "term": "Œ∫ ‚àà CARDINALITY",
                  "definition": "Cardinality constraint"
                },
                {
                  "term": "cascade_boundary ‚àà ùîπ",
                  "definition": "Whether cascade propagation stops here [v2.0]"
                }
              ]
            },
            {
              "type": "admonition",
              "level": "important",
              "text": "**Dependency Direction vs Impact Flow Semantics [v2.4.4 Clarification]**\n\nDependencies have TWO distinct directional semantics:\n\n**1. Structural Direction (src ‚Üí tgt)**: The dependency arrow shows WHO depends ON WHOM.\n- `d.src ‚Üí d.tgt` means \"src depends on tgt\" (src is dependent, tgt is dependee)\n- `realizes`: concrete_impl ‚Üí abstract_spec (impl depends on spec)\n- `requires`: component_A ‚Üí component_B (A depends on B)\n- Coherence (G6): `pos(d.src) ‚â• pos(d.tgt)` (dependent ‚â• dependee in concreteness)\n\n**2. Impact Flow**: CASCADE walks deps where `d.src.elem = changed_element`, propagates to `d.tgt`.\n- When element e changes, impact flows TO elements e depends on\n- Example: Component C realizes Spec S ‚Üí dependency `C ‚Üí S`\n  - If C changes: cascade finds `d.src=C`, propagates impact to S ‚úì\n  - If S changes: cascade finds deps `d.src=S` (none of type realizes), no auto-propagation to C\n- This prevents circular cascades while maintaining traceability\n\n**Reconciling 'changes cascade down'**: This phrase in ¬ß4.6 means Coherence prevents upward structural dependencies (abstract layers don't depend on concrete). Impact flows along dependency arrows (dependent ‚Üí dependee), which by G6 is always same-tier or concrete‚Üíabstract."
            },
            {
              "type": "paragraph",
              "text": "Notation: src(d) = d.src, tgt(d) = d.tgt; d : e‚ÇÅ ‚Üí[Œ¥] e‚ÇÇ means dependency d from e‚ÇÅ to e‚ÇÇ of type Œ¥"
            }
          ]
        },
        {
          "id": "sec-02-4",
          "number": "2.4",
          "title": "Constraint",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "A Constraint is a rule that must hold across elements."
            },
            {
              "type": "admonition",
              "level": "note",
              "text": "SOUNDNESS FIX [v2.0]: The predicate language œÜ is now formally specified as a combination of QF_LIA, QF_LRA, and QF_UF (Quantifier-Free Linear Integer Arithmetic, Linear Real Arithmetic, and Uninterpreted Functions with Equality). This ensures decidability per SMT-LIB 2.6 standard using Nelson-Oppen combination."
            },
            {
              "type": "paragraph",
              "text": "**Definition 2.12 (Predicate Language - SMT-LIB Constraint Logic)**"
            },
            {
              "type": "paragraph",
              "text": "The constraint predicate language combines three decidable SMT-LIB theories:"
            },
            {
              "type": "list",
              "items": [
                "**QF_LIA**: Quantifier-Free Linear Integer Arithmetic (sort Int)",
                "**QF_LRA**: Quantifier-Free Linear Real Arithmetic (sort Real)",
                "**QF_UF**: Quantifier-Free Uninterpreted Functions with Equality"
              ]
            },
            {
              "type": "paragraph",
              "text": "**Sorts and Coercions**:"
            },
            {
              "type": "code",
              "lines": [
                "Sorts: Int, Real, Bool, Element, Layer, Dependency",
                "Coercion: to_real : Int ‚Üí Real (standard SMT-LIB coercion)",
                "No implicit coercion from Real to Int (explicit floor/ceil required)"
              ]
            },
            {
              "type": "paragraph",
              "text": "**Nelson-Oppen Requirements**: QF_LIA, QF_LRA, and QF_UF are stably infinite and have disjoint signatures (Int/Real arithmetic operators vs uninterpreted functions), satisfying combination requirements (Nelson & Oppen 1979)."
            },
            {
              "type": "paragraph",
              "text": "Terms:"
            },
            {
              "type": "code",
              "lines": [
                "t ::= x : œÉ                    -- Typed variable (œÉ ‚àà {Int, Real, Bool, Element, ...})",
                "    | n : Int                  -- Integer literal",
                "    | r : Real                 -- Real literal",
                "    | t‚ÇÅ + t‚ÇÇ | t‚ÇÅ - t‚ÇÇ        -- Addition, subtraction (same sort)",
                "    | n √ó t                    -- Scalar multiplication (n : Int)",
                "    | to_real(t)               -- Int ‚Üí Real coercion",
                "    | f(t‚ÇÅ, ..., t‚Çô)           -- Uninterpreted function (signature declared)",
                "    | e.œÄ(p) : VALUE           -- Property access (runtime value)",
                "    | |S| : Int                -- Set cardinality (finite sets only)",
                "    | count(S, pred) : Int     -- Counting with predicate (see below)"
              ]
            },
            {
              "type": "paragraph",
              "text": "**Finite Set Cardinality Semantics**: The `count(S, pred)` operator is defined for FINITE element sets only. Given a finite set S ‚äÜ E and predicate pred : E ‚Üí Bool, `count(S, pred) = |{e ‚àà S | pred(e)}|`. This is decidable because all specifications have finite E, L, D, C sets per ¬ß3 (WF-ID ensures finite identifiers)."
            },
            {
              "type": "admonition",
              "level": "important",
              "text": "**SMT Solver Requirements**: Constraints using |S| or count() require an SMT solver with BOTH QF_LIA/QF_LRA theory AND finite sets theory (e.g., Z3 with (set Int) or CVC5 with finite sets). Pure QF_LIA + QF_UF solvers cannot handle set cardinality. Implementations may choose to: (1) require sets-capable solver for full K0 conformance, OR (2) restrict Kernel to QF_LIA/LRA/UF only and treat |S|/count() as K1+ extensions."
            },
            {
              "type": "paragraph",
              "text": "Atomic Formulas:"
            },
            {
              "type": "code",
              "lines": [
                "a ::= t‚ÇÅ = t‚ÇÇ                  -- Equality",
                "    | t‚ÇÅ ‚â† t‚ÇÇ                  -- Disequality",
                "    | t‚ÇÅ < t‚ÇÇ | t‚ÇÅ ‚â§ t‚ÇÇ        -- Integer/real comparisons",
                "    | t‚ÇÅ > t‚ÇÇ | t‚ÇÅ ‚â• t‚ÇÇ",
                "    | e ‚àà S                    -- Set membership",
                "    | d : e‚ÇÅ ‚Üí e‚ÇÇ              -- Dependency existence"
              ]
            },
            {
              "type": "paragraph",
              "text": "Formulas (Quantifier-Free):"
            },
            {
              "type": "code",
              "lines": [
                "œÜ ::= a                        -- Atomic formula",
                "    | ¬¨œÜ                       -- Negation",
                "    | œÜ‚ÇÅ ‚àß œÜ‚ÇÇ                  -- Conjunction",
                "    | œÜ‚ÇÅ ‚à® œÜ‚ÇÇ                  -- Disjunction",
                "    | œÜ‚ÇÅ ‚áí œÜ‚ÇÇ                  -- Implication",
                "    | if œÜ‚ÇÅ then œÜ‚ÇÇ else œÜ‚ÇÉ   -- Conditional"
              ]
            },
            {
              "type": "paragraph",
              "text": "Bounded Quantification (decidable extension):"
            },
            {
              "type": "code",
              "lines": [
                "œÜ ::= ‚àÄ e ‚àà E_finite. œÜ        -- Universal over finite set",
                "    | ‚àÉ e ‚àà E_finite. œÜ        -- Existential over finite set"
              ]
            },
            {
              "type": "theorem",
              "label": "Theorem 2.1 (Constraint Decidability)",
              "text": "For any constraint c with predicate œÜ in QF_LIA + QF_LRA + QF_UF (combined via Nelson-Oppen): sat(œÜ) is decidable in NP (via SMT solving); unsat(œÜ) is decidable in co-NP"
            },
            {
              "type": "definition",
              "label": "Definition 2.13 (Constraint Category)",
              "text": "CATEGORY = {existence, uniqueness, completeness, consistency, validity, dependency, ordering, coverage, alignment, boundary}"
            },
            {
              "type": "definition",
              "label": "Definition 2.14 (Severity)",
              "text": "SEVERITY = {error, warning, info}"
            },
            {
              "type": "definition",
              "label": "Definition 2.15 (Scope)",
              "text": "scope ::= ‚ü®srcLayer: ID*, srcType: TYPE*, tgtLayer: ID*, tgtType: TYPE*‚ü©"
            },
            {
              "type": "definition",
              "label": "Definition 2.16 (Constraint)",
              "text": "c ::= ‚ü®id, name, scope, cat, sev, œÜ, msg, priority‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "id ‚àà ID",
                  "definition": "Unique identifier"
                },
                {
                  "term": "name ‚àà NAME",
                  "definition": "Human-readable name"
                },
                {
                  "term": "scope ‚àà SCOPE",
                  "definition": "What elements this applies to"
                },
                {
                  "term": "cat ‚àà CATEGORY",
                  "definition": "Constraint category"
                },
                {
                  "term": "sev ‚àà SEVERITY",
                  "definition": "Violation severity"
                },
                {
                  "term": "œÜ : P(E) √ó P(D) ‚Üí ùîπ",
                  "definition": "Predicate (in SMT-LIB QF_LIA + QF_LRA + QF_UF)"
                },
                {
                  "term": "msg : P(E) ‚Üí NAME",
                  "definition": "Error message generator"
                },
                {
                  "term": "priority ‚àà ‚Ñï",
                  "definition": "For conflict resolution [v2.0]"
                }
              ]
            },
            {
              "type": "definition",
              "label": "Definition 2.17 (Constraint Satisfaction)",
              "text": "S ‚ä® c iff c.œÜ(elements(S), dependencies(S)) = ‚ä§"
            },
            {
              "type": "definition",
              "label": "Definition 2.18 (Constraint Conflict) [v2.0]",
              "text": "conflict(c‚ÇÅ, c‚ÇÇ) iff unsat(c‚ÇÅ.œÜ ‚àß c‚ÇÇ.œÜ)"
            },
            {
              "type": "heading",
              "level": 3,
              "text": "Normative SMT-LIB 2.6 Encoding"
            },
            {
              "type": "paragraph",
              "text": "**Definition 2.19 (SMT-LIB 2.6 Constraint Encoding) [v2.5]**: The following SMT-LIB 2.6 preamble defines the normative encoding for STRATUM constraints. Implementations MUST use this exact logic declaration and sort/function signatures for K0 conformance."
            },
            {
              "type": "code",
              "language": "smt2",
              "lines": [
                "; SMT-LIB 2.6 Standard Preamble for STRATUM Constraints",
                "(set-logic QF_AUFLIRA)  ; Combined logic: Arrays, Uninterpreted Functions, Linear Integer/Real Arithmetic",
                "",
                "; Core domain sorts",
                "(declare-sort Element 0)    ; Element identifiers",
                "(declare-sort Layer 0)      ; Layer identifiers",
                "(declare-sort Dependency 0) ; Dependency identifiers",
                "",
                "; Element projection functions (uninterpreted)",
                "(declare-fun elem-id (Element) Int)       ; Element ‚Üí unique integer ID",
                "(declare-fun elem-layer (Element) Layer)  ; Element ‚Üí Layer membership",
                "(declare-fun elem-type (Element) Int)     ; Element ‚Üí type code",
                "",
                "; Layer projection functions",
                "(declare-fun layer-tier (Layer) Int)      ; Layer ‚Üí tier code (0=motivation, 1=logical, 2=realization, 3=grounding)",
                "(declare-fun layer-order (Layer) Int)     ; Layer ‚Üí position within tier",
                "",
                "; Dependency projection functions",
                "(declare-fun dep-src (Dependency) Element)     ; Dependency ‚Üí source element",
                "(declare-fun dep-tgt (Dependency) Element)     ; Dependency ‚Üí target element",
                "(declare-fun dep-type (Dependency) Int)        ; Dependency ‚Üí type code",
                "(declare-fun dep-strength (Dependency) Int)    ; 0=soft, 1=hard",
                "",
                "; Property access function (uninterpreted, domain-specific)",
                "; Usage: (declare-fun prop-complexity (Element) Int)",
                "; Each property gets its own typed accessor function",
                "",
                "; Set cardinality (for finite element/dependency sets)",
                "; Encoded as integer constants: |E| = elem-count, |D| = dep-count",
                "(declare-const elem-count Int)",
                "(declare-const dep-count Int)",
                "(assert (>= elem-count 0))",
                "(assert (>= dep-count 0))",
                "",
                "; Tier ordering axioms (if needed for coherence constraints)",
                "; (assert (forall ((l1 Layer) (l2 Layer))",
                ";   (=> (< (layer-tier l1) (layer-tier l2))",
                ";       (< (layer-position l1) (layer-position l2)))))",
                "; Note: Quantifiers push logic to AUFLIRA (undecidable), avoid if possible"
              ]
            },
            {
              "type": "admonition",
              "level": "note",
              "text": "**Logic Selection Rationale**: QF_AUFLIRA combines four theories: Arrays (for element/dependency collections), Uninterpreted Functions (for property access), Linear Integer Arithmetic (for counts, tier codes), and Linear Real Arithmetic (for attenuation factors). This is the MINIMAL combined logic that supports all Kernel constraint patterns. Solvers: Z3 4.8+, CVC5 1.0+, MathSAT 5.6+ all support QF_AUFLIRA."
            },
            {
              "type": "paragraph",
              "text": "**Example Constraint**: Feature test coverage (¬ß4.2 completeness example) encoded in SMT-LIB 2.6:"
            },
            {
              "type": "code",
              "language": "smt2",
              "lines": [
                "; Constraint: ‚àÄ feature f. ‚àÉ test t. tests(t, f)",
                "; Property declarations",
                "(declare-fun is-feature (Element) Bool)",
                "(declare-fun is-test (Element) Bool)",
                "(declare-fun tests-feature (Dependency) Bool)  ; dep.type = validates",
                "",
                "; Finite quantification over elements (expanded to conjunction)",
                "; For specification with elements e1, e2, ..., en:",
                "(assert (=> (is-feature e1)",
                "            (or (and (tests-feature d1) (= (dep-src d1) t1) (= (dep-tgt d1) e1))",
                "                (and (tests-feature d2) (= (dep-src d2) t2) (= (dep-tgt d2) e1))",
                "                ; ... for all test elements t_i and dependencies d_j",
                "            )))",
                "; Repeat for e2, e3, ..., en",
                "",
                "; Alternative encoding using counting (requires finite sets extension):",
                "; (assert (forall ((f Element))",
                ";   (=> (is-feature f)",
                ";       (> (select feature-test-count f) 0))))",
                "; where (declare-fun feature-test-count (Array Element Int))"
              ]
            },
            {
              "type": "admonition",
              "level": "warning",
              "text": "**Bounded Quantification Trade-off**: Quantified formulas (‚àÄ, ‚àÉ) over finite element sets are DECIDABLE when expanded to finite conjunctions/disjunctions, but may cause exponential blowup. K0 implementations MAY choose to: (1) fully expand quantifiers at query-time (guarantees decidability, may be slow), OR (2) use heuristic quantifier instantiation (fast, may report 'unknown' for complex constraints). K1+ conformance REQUIRES full expansion with definite sat/unsat answers."
            },
            {
              "type": "paragraph",
              "text": "Resolution: When conflict(c‚ÇÅ, c‚ÇÇ), apply constraint with higher priority. If equal priority, flag for manual resolution."
            }
          ]
        },
        {
          "id": "sec-02-5",
          "number": "2.5",
          "title": "Binding",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "A Binding connects abstract elements to concrete artifacts."
            },
            {
              "type": "definition",
              "label": "Definition 2.19 (Binding Completeness)",
              "text": "COMPLETENESS = {complete, partial, stub}"
            },
            {
              "type": "definition",
              "label": "Definition 2.20 (Verification State) [v2.0]",
              "text": "VERIFICATION = {unverified, pending, verified, failed, stale}"
            },
            {
              "type": "paragraph",
              "text": "State transitions:"
            },
            {
              "type": "code",
              "lines": [
                "unverified ‚Üí pending   (verification initiated)",
                "pending ‚Üí verified     (verification succeeded)",
                "pending ‚Üí failed       (verification failed)",
                "verified ‚Üí stale       (bound artifact changed)",
                "stale ‚Üí pending        (re-verification initiated)",
                "failed ‚Üí pending       (retry verification)"
              ]
            },
            {
              "type": "definition",
              "label": "Definition 2.21 (Artifact Reference)",
              "text": "artifact ::= ‚ü®type: ARTIFACT_TYPE, uri: URI, hash: HASH, verified_at: TIME*‚ü©"
            },
            {
              "type": "paragraph",
              "text": "ARTIFACT_TYPE = {file, symbol, line_range, url, database_record, ...}"
            },
            {
              "type": "definition",
              "label": "Definition 2.22 (Binding)",
              "text": "b ::= ‚ü®id, abstract, concrete, completeness, verification, evidence‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "id ‚àà ID",
                  "definition": "Unique identifier"
                },
                {
                  "term": "abstract ‚àà ID √ó ID",
                  "definition": "(element_id, layer_id)"
                },
                {
                  "term": "concrete ‚àà ARTIFACT",
                  "definition": "Physical artifact"
                },
                {
                  "term": "completeness ‚àà COMPLETENESS",
                  "definition": "How complete is the binding"
                },
                {
                  "term": "verification ‚àà VERIFICATION",
                  "definition": "Current verification state [EXPANDED]"
                },
                {
                  "term": "evidence ‚àà List<EVIDENCE>",
                  "definition": "Verification evidence [v2.0]"
                }
              ]
            },
            {
              "type": "definition",
              "label": "Definition 2.23 (Evidence) [v2.0]",
              "text": "evidence ::= ‚ü®type: EVIDENCE_TYPE, timestamp: TIME, result: ùîπ, details: VALUE‚ü©"
            },
            {
              "type": "paragraph",
              "text": "EVIDENCE_TYPE = {test_result, static_analysis, manual_review, audit_log, ...}"
            }
          ]
        },
        {
          "id": "sec-02-6",
          "number": "2.6",
          "title": "Cascade Rule",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "A Cascade Rule defines how changes propagate."
            },
            {
              "type": "definition",
              "label": "Definition 2.24 (Change Type)",
              "text": "CHANGE = {create, update, delete, deprecate}"
            },
            {
              "type": "definition",
              "label": "Definition 2.25 (Impact Level)",
              "text": "IMPACT = {‚ä•, cosmetic, degraded, breaking}"
            },
            {
              "type": "paragraph",
              "text": "with total order: ‚ä• < cosmetic < degraded < breaking"
            },
            {
              "type": "paragraph",
              "text": "‚ä• represents \"no impact\" - explicitly included for completeness"
            },
            {
              "type": "definition",
              "label": "Definition 2.26 (Cascade Rule)",
              "text": "r ::= ‚ü®id, trigger, propagation, effect‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "code",
              "lines": [
                "trigger     = ‚ü®elementTypes: TYPE*, changeType: CHANGE‚ü©",
                "propagation = ‚ü®depTypes: DEPTYPE*, direction: DIR, maxDepth: ‚Ñï*, respectBoundary: ùîπ‚ü©",
                "effect      = ‚ü®severity: IMPACT, action: NAME, attenuates: ùîπ‚ü©"
              ]
            },
            {
              "type": "paragraph",
              "text": "DIR = {forward, backward, both}"
            },
            {
              "type": "paragraph",
              "text": "respectBoundary: if true, stop at dependencies with cascade_boundary = ‚ä§"
            }
          ]
        },
        {
          "id": "sec-02-7",
          "number": "2.7",
          "title": "Specification",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "A Specification is a complete STRATUM model."
            },
            {
              "type": "definition",
              "label": "Definition 2.27 (Specification)",
              "text": "S ::= ‚ü®id, name, domain, version, L, E, D, C, B, R, H‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "id ‚àà ID",
                  "definition": "Specification identifier"
                },
                {
                  "term": "name ‚àà NAME",
                  "definition": "Human-readable name"
                },
                {
                  "term": "domain ‚àà NAME",
                  "definition": "Domain profile identifier"
                },
                {
                  "term": "version ‚àà VersionVector",
                  "definition": "Causal version [v2.0 changed]"
                },
                {
                  "term": "L ‚äÜ LAYER",
                  "definition": "Set of layers"
                },
                {
                  "term": "E ‚äÜ ELEMENT",
                  "definition": "Set of elements"
                },
                {
                  "term": "D ‚äÜ DEPENDENCY",
                  "definition": "Set of dependencies"
                },
                {
                  "term": "C ‚äÜ CONSTRAINT",
                  "definition": "Set of constraints"
                },
                {
                  "term": "B ‚äÜ BINDING",
                  "definition": "Set of bindings"
                },
                {
                  "term": "R ‚äÜ CASCADE_RULE",
                  "definition": "Set of cascade rules"
                },
                {
                  "term": "H ‚àà HISTORY",
                  "definition": "Operation history for CRDT [v2.0]"
                }
              ]
            },
            {
              "type": "definition",
              "label": "Definition 2.28 (History) [v2.0]",
              "text": "H = List<Operation>; Operation = ‚ü®op_id: ID, actor: ACTOR, clock: CLOCK, type: OP_TYPE, payload‚ü©"
            },
            {
              "type": "paragraph",
              "text": "OP_TYPE = {add_element, remove_element, update_element, add_dep, ...}"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-02-policy",
      "number": "2.8",
      "title": "Policy [v2.5]",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "A Policy defines automated remediation workflows triggered by violations, changes, or specification states. Policies complement Constraints: constraints define WHAT must hold, policies define HOW to respond when constraints don't hold."
        },
        {
          "type": "definition",
          "label": "Definition 2.28 (Policy)",
          "text": "p ::= ‚ü®id, name, appliesTo, actions, priority‚ü©"
        },
        {
          "type": "paragraph",
          "text": "where:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "id ‚àà ID",
              "definition": "Unique identifier"
            },
            {
              "term": "name ‚àà NAME",
              "definition": "Human-readable name"
            },
            {
              "term": "appliesTo",
              "definition": "Trigger conditions (see Definition 2.29)"
            },
            {
              "term": "actions",
              "definition": "Response actions (see Definition 2.30)"
            },
            {
              "term": "priority ‚àà ‚Ñï",
              "definition": "For conflict resolution (higher = more important)"
            }
          ]
        },
        {
          "type": "definition",
          "label": "Definition 2.29 (Policy Trigger)",
          "text": "appliesTo ::= ‚ü®constraintCategories?, guarantees?, integrityLevels?, severities?‚ü©"
        },
        {
          "type": "paragraph",
          "text": "where:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "constraintCategories ‚àà P(CATEGORY)",
              "definition": "Optional: trigger on specific constraint types"
            },
            {
              "term": "guarantees ‚àà P({'G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7'})",
              "definition": "Optional: trigger on guarantee violations"
            },
            {
              "term": "integrityLevels ‚àà P(IntegrityLevel)",
              "definition": "Optional: trigger on ASIL_D, DAL_A, etc."
            },
            {
              "term": "severities ‚àà P(SEVERITY)",
              "definition": "Optional: trigger on error, warning, info"
            }
          ]
        },
        {
          "type": "definition",
          "label": "Definition 2.30 (Policy Actions)",
          "text": "actions ::= ‚ü®suggestedFixes?, requiredReviewers?, requiredEvidenceTypes?, minimumEvidenceCount?, blockingBehavior, notificationChannels?‚ü©"
        },
        {
          "type": "paragraph",
          "text": "where:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "suggestedFixes ‚àà FixTemplate*",
              "definition": "Optional: automated fix suggestions"
            },
            {
              "term": "requiredReviewers ‚àà ‚ü®role: NAME, count: ‚Ñï, escalationTimeout?: Duration‚ü©?",
              "definition": "Optional: human review requirements"
            },
            {
              "term": "requiredEvidenceTypes ‚àà P(EvidenceType)?",
              "definition": "Optional: types of evidence required"
            },
            {
              "term": "minimumEvidenceCount ‚àà ‚Ñï?",
              "definition": "Optional: minimum evidence records"
            },
            {
              "term": "blockingBehavior ‚àà {block_merge, warn_only, auto_fix}",
              "definition": "Required: enforcement level"
            },
            {
              "term": "notificationChannels ‚àà NAME*?",
              "definition": "Optional: where to send alerts"
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Standard Policies"
        },
        {
          "type": "paragraph",
          "text": "STRATUM v2.5 defines standard policies shipped with domain profiles:"
        },
        {
          "type": "code",
          "language": "typescript",
          "lines": [
            "// POL-ASIL-D-REVIEW: Automotive safety-critical",
            "{",
            "  id: 'POL-ASIL-D-REVIEW',",
            "  name: 'ASIL-D Dual Review Requirement',",
            "  appliesTo: { integrityLevels: ['ASIL_D'] },",
            "  actions: {",
            "    requiredReviewers: { role: 'safety-engineer', count: 2,",
            "                         escalationTimeout: '48h' },",
            "    requiredEvidenceTypes: ['static_analysis', 'manual_review'],",
            "    minimumEvidenceCount: 2,",
            "    blockingBehavior: 'block_merge'",
            "  },",
            "  priority: 1000",
            "}",
            "",
            "// POL-DAL-A-EVIDENCE: Avionics critical",
            "{",
            "  id: 'POL-DAL-A-EVIDENCE',",
            "  name: 'DAL-A MC/DC + Formal Proof Required',",
            "  appliesTo: { integrityLevels: ['DAL_A'] },",
            "  actions: {",
            "    requiredEvidenceTypes: ['mcdc_coverage', 'formal_proof'],",
            "    minimumEvidenceCount: 2,",
            "    blockingBehavior: 'block_merge'",
            "  },",
            "  priority: 1000",
            "}",
            "",
            "// POL-G4-BINDING: Groundedness assistance",
            "{",
            "  id: 'POL-G4-BINDING',",
            "  name: 'Suggest Binding Creation',",
            "  appliesTo: { guarantees: ['G4'] },",
            "  actions: {",
            "    suggestedFixes: [",
            "      { template: 'create_binding', params: { layer: 'grounding' } }",
            "    ],",
            "    blockingBehavior: 'warn_only'",
            "  },",
            "  priority: 500",
            "}",
            "",
            "// POL-G7-EXPLAIN: Require explanations",
            "{",
            "  id: 'POL-G7-EXPLAIN',",
            "  name: 'Require Human-Readable Explanation',",
            "  appliesTo: { guarantees: ['G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7'] },",
            "  actions: {",
            "    blockingBehavior: 'warn_only'  // G7 provides explanations automatically",
            "  },",
            "  priority: 100",
            "}"
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Formal Policy Semantics"
        },
        {
          "type": "definition",
          "label": "Definition 2.31 (Policy Evaluation Semantics) [v2.5]",
          "text": "evaluatePolicies : Spec √ó P(Violation) ‚Üí P(PolicyAction)"
        },
        {
          "type": "paragraph",
          "text": "Given specification S and violation set V, the policy evaluator returns the set of triggered actions:"
        },
        {
          "type": "code",
          "lines": [
            "evaluatePolicies(S, V) = ‚ãÉ_{p ‚àà policies(S)} match(p, V)",
            "",
            "where:",
            "  match(p, V) = if triggers(p, V)",
            "                then {‚ü®p.id, p.actions, violations_matched‚ü©}",
            "                else ‚àÖ",
            "",
            "  triggers(p, V) = ‚àÉ v ‚àà V. satisfies(v, p.appliesTo)",
            "",
            "  satisfies(v, t) = (t.constraintCategories = Œµ ‚à® v.constraint.cat ‚àà t.constraintCategories)",
            "                  ‚àß (t.guarantees = Œµ ‚à® violatesGuarantee(v) ‚àà t.guarantees)",
            "                  ‚àß (t.integrityLevels = Œµ ‚à® v.element.integrityLevel ‚àà t.integrityLevels)",
            "                  ‚àß (t.severities = Œµ ‚à® v.constraint.sev ‚àà t.severities)",
            "",
            "  violatesGuarantee : Violation ‚Üí {'G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7'}*",
            "  violatesGuarantee(v) = { g | g ‚àà guarantees(S) ‚àß ¬¨g(S) ‚àß v ‚àà witnesses(g, S) }"
          ]
        },
        {
          "type": "definition",
          "label": "Definition 2.32 (Policy Conflict Resolution) [v2.5]",
          "text": "When multiple policies trigger with conflicting blockingBehavior, resolve via priority:"
        },
        {
          "type": "code",
          "lines": [
            "conflictingPolicies(A) = { (a‚ÇÅ, a‚ÇÇ) ‚àà A √ó A | conflicts(a‚ÇÅ.behavior, a‚ÇÇ.behavior) }",
            "",
            "conflicts(b‚ÇÅ, b‚ÇÇ) = (b‚ÇÅ = block_merge ‚àß b‚ÇÇ = auto_fix)",
            "                  ‚à® (b‚ÇÅ = auto_fix ‚àß b‚ÇÇ = block_merge)",
            "                  ‚à® (b‚ÇÅ = warn_only ‚àß b‚ÇÇ ‚â† warn_only)",
            "",
            "resolve(A) = if conflictingPolicies(A) = ‚àÖ",
            "             then A",
            "             else { a ‚àà A | a.priority = max_{a' ‚àà A} a'.priority }",
            "",
            "finalBehavior(A) = let A' = resolve(A) in",
            "                   if ‚àÉ a ‚àà A'. a.behavior = block_merge",
            "                   then block_merge",
            "                   else if ‚àÉ a ‚àà A'. a.behavior = auto_fix",
            "                   then auto_fix",
            "                   else warn_only"
          ]
        },
        {
          "type": "theorem",
          "label": "Theorem 2.2 (Policy Evaluation Determinism) [v2.5]",
          "text": "For any specification S and violation set V, evaluatePolicies(S, V) is deterministic and terminates in O(|policies(S)| √ó |V|) time."
        },
        {
          "type": "admonition",
          "level": "note",
          "text": "**Proof Sketch**: Each policy p is checked against each violation v (O(|P| √ó |V|)). The satisfies predicate evaluates in O(1) given finite sets. Conflict resolution selects highest-priority policy in O(|A|) where |A| ‚â§ |P|. Total: O(|P| √ó |V|) + O(|P|) = O(|P| √ó |V|). ‚àé"
        },
        {
          "type": "definition",
          "label": "Definition 2.33 (Policy Merge Semantics) [v2.5]",
          "text": "When composing specifications S‚ÇÅ ‚äï S‚ÇÇ, policies merge with override semantics:"
        },
        {
          "type": "code",
          "lines": [
            "policies(S‚ÇÅ ‚äï S‚ÇÇ) = override(policies(S‚ÇÅ), policies(S‚ÇÇ))",
            "",
            "where:",
            "  override(P‚ÇÅ, P‚ÇÇ) = { p ‚àà P‚ÇÅ | p.id ‚àâ ids(P‚ÇÇ) } ‚à™ P‚ÇÇ",
            "",
            "  ids(P) = { p.id | p ‚àà P }"
          ]
        },
        {
          "type": "paragraph",
          "text": "**Rationale**: Higher-level compositions (e.g., project-level policies) override lower-level defaults (e.g., domain profile policies). This follows the 'configuration as code' principle where composition S‚ÇÅ ‚äï S‚ÇÇ means 'S‚ÇÇ extends S‚ÇÅ with overrides'."
        },
        {
          "type": "paragraph",
          "text": "**Policy Evaluation**: The operational implementation of `evaluatePolicies(S, violations)` follows Definitions 2.31-2.33 above. For validation integration, policies are evaluated after constraint checking per Operation 7.1 (validate). Policy conflict resolution uses priority ordering per ¬ß23 (same mechanism as Constraint priority)."
        },
        {
          "type": "admonition",
          "level": "note",
          "text": "**Conformance**: Policy system is **K1 (Certified-Aware)**, not K0. K0 implementations may ignore policies. K1+ implementations MUST evaluate policies and respect `blockingBehavior`."
        }
      ]
    },
    {
      "id": "sec-03",
      "number": "3",
      "title": "Well-Formedness Conditions",
      "defs": [],
      "children": [
        {
          "id": "sec-03-1",
          "number": "3.1",
          "title": "Structural Well-Formedness",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "A specification S is structurally well-formed iff all of the following hold:"
            },
            {
              "type": "rule",
              "label": "WF-ID: Unique Identifiers",
              "formula": "‚àÄ e‚ÇÅ, e‚ÇÇ ‚àà E. e‚ÇÅ.id = e‚ÇÇ.id ‚Üí e‚ÇÅ = e‚ÇÇ\n‚àÄ l‚ÇÅ, l‚ÇÇ ‚àà L. l‚ÇÅ.id = l‚ÇÇ.id ‚Üí l‚ÇÅ = l‚ÇÇ\n‚àÄ d‚ÇÅ, d‚ÇÇ ‚àà D. d‚ÇÅ.id = d‚ÇÇ.id ‚Üí d‚ÇÅ = d‚ÇÇ\n‚àÄ c‚ÇÅ, c‚ÇÇ ‚àà C. c‚ÇÅ.id = c‚ÇÇ.id ‚Üí c‚ÇÅ = c‚ÇÇ\n‚àÄ b‚ÇÅ, b‚ÇÇ ‚àà B. b‚ÇÅ.id = b‚ÇÇ.id ‚Üí b‚ÇÅ = b‚ÇÇ"
            },
            {
              "type": "rule",
              "label": "WF-LAYER: Layer Membership",
              "formula": "‚àÄ e ‚àà E. ‚àÉ l ‚àà L. e.l = l.id",
              "description": "Every element belongs to a layer that exists"
            },
            {
              "type": "rule",
              "label": "WF-TYPE: Type Vocabulary",
              "formula": "‚àÄ e ‚àà E. let l = layer(e) in e.œÑ ‚àà l.T",
              "description": "Every element's type is in its layer's vocabulary"
            },
            {
              "type": "rule",
              "label": "WF-DEP-ENDPOINTS: Dependency Endpoints",
              "formula": "‚àÄ d ‚àà D. ‚àÉ e‚ÇÅ, e‚ÇÇ ‚àà E. d.src.elem = e‚ÇÅ.id ‚àß d.tgt.elem = e‚ÇÇ.id",
              "description": "Dependency endpoints reference existing elements"
            },
            {
              "type": "rule",
              "label": "WF-BINDING-SOURCE: Binding Sources",
              "formula": "‚àÄ b ‚àà B. ‚àÉ e ‚àà E. b.abstract.elem = e.id",
              "description": "Binding sources reference existing elements"
            },
            {
              "type": "rule",
              "label": "WF-LAYER-DEPS: Layer Dependencies",
              "formula": "‚àÄ l ‚àà L. ‚àÄ dep ‚àà l.deps. ‚àÉ l' ‚àà L. l'.id = dep",
              "description": "Layer dependencies reference existing layers"
            },
            {
              "type": "rule",
              "label": "WF-TIER-ORDER: Tier Ordering",
              "formula": "‚àÄ l ‚àà L. ‚àÄ dep ‚àà l.deps. let l' = getLayer(dep) in pos(l') ‚â§ pos(l)",
              "description": "Layers only depend on layers at same or higher abstraction"
            }
          ]
        },
        {
          "id": "sec-03-2",
          "number": "3.2",
          "title": "Tier Completeness",
          "defs": [],
          "content": [
            {
              "type": "rule",
              "label": "WF-TIER-COMPLETE: All Tiers Present",
              "formula": "‚àÄ t ‚àà TIER. ‚àÉ l ‚àà L. l.tier = t",
              "description": "Every tier has at least one layer"
            },
            {
              "type": "paragraph",
              "text": "This ensures the specification addresses all four fundamental questions:"
            },
            {
              "type": "list",
              "items": [
                "motivation: WHY does this exist?",
                "logical: WHAT is the structure?",
                "realization: HOW does it work?",
                "grounding: WHERE does it exist?"
              ]
            }
          ]
        },
        {
          "id": "sec-03-3",
          "number": "3.3",
          "title": "Acyclicity",
          "defs": [],
          "content": [
            {
              "type": "rule",
              "label": "WF-ACYCLIC-LAYERS: No Layer Cycles",
              "formula": "Let G_L = (L, {(l, l') | l' ‚àà l.deps})\nG_L is acyclic"
            },
            {
              "type": "rule",
              "label": "WF-ACYCLIC-HARD: No Hard Dependency Cycles",
              "formula": "Let G_D = (E, {(e‚ÇÅ, e‚ÇÇ) | ‚àÉd ‚àà D. d.src.elem = e‚ÇÅ.id ‚àß d.tgt.elem = e‚ÇÇ.id ‚àß d.œÉ = hard})\nG_D is acyclic",
              "description": "Hard dependencies must be acyclic"
            },
            {
              "type": "paragraph",
              "text": "Note: Soft dependencies MAY form cycles (for mutual references, etc.)"
            },
            {
              "type": "rule",
              "label": "WF-SOFT-CYCLE-BOUNDED: Soft Cycle Boundaries",
              "formula": "‚àÄ cycle C in G_D^soft. ‚àÉ d ‚àà C. d.cascade_boundary = ‚ä§\nwhere G_D^soft = (E, {(e‚ÇÅ, e‚ÇÇ) | ‚àÉd ‚àà D. d.src.elem = e‚ÇÅ.id ‚àß d.tgt.elem = e‚ÇÇ.id ‚àß d.œÉ = soft})",
              "description": "Every soft dependency cycle must have at least one cascade boundary to prevent infinite propagation"
            },
            {
              "type": "rule",
              "label": "WF-CASCADE-TERMINATION: Cascade Depth Bounded",
              "formula": "‚àÄ r ‚àà R. ‚àÉ n ‚àà ‚Ñï. r.max_depth = n\n‚àÄ cascade path P in impact(S, e, r). |P| ‚â§ r.max_depth",
              "description": "Cascade rules must specify maximum propagation depth, and all cascade paths must respect this bound"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-04",
      "number": "4",
      "title": "Semantic Properties (The Seven Guarantees)",
      "defs": [],
      "children": [
        {
          "id": "sec-04-1",
          "number": "4.1",
          "title": "Traceability",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 4.1 (Root Element)",
              "text": "root(e) ‚â° layer(e).tier = motivation ‚àß ¬¨‚àÉd ‚àà D. d.tgt.elem = e.id ‚àß d.Œ¥ = traces_to"
            },
            {
              "type": "definition",
              "label": "Definition 4.2 (Trace Path)",
              "text": "tracePath(e) = shortest path from e to some e' where root(e') following traces_to dependencies from target to source (impl ‚Üí requirement)"
            },
            {
              "type": "guarantee",
              "label": "GUARANTEE G1 - TRACEABILITY",
              "formula": "‚àÄ e ‚àà E. ‚àÉ e' ‚àà E. root(e') ‚àß reachable(e, e', traces_to)",
              "description": "Every element traces back to a root element in the motivation tier (traces_to goes impl ‚Üí requirement)"
            },
            {
              "type": "paragraph",
              "text": "Formally, for specification S:\nTraceable(S) ‚â° ‚àÄ e ‚àà elements(S). tracePath(e) ‚â† ‚àÖ"
            }
          ]
        },
        {
          "id": "sec-04-2",
          "number": "4.2",
          "title": "Completeness",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 4.3 (Constraint Satisfaction)",
              "text": "S ‚ä® c ‚â° c.œÜ(elements(S), dependencies(S)) = ‚ä§"
            },
            {
              "type": "definition",
              "label": "Definition 4.4 (Error Constraints)",
              "text": "ErrorConstraints(S) = {c ‚àà constraints(S) | c.sev = error}"
            },
            {
              "type": "guarantee",
              "label": "GUARANTEE G2 - COMPLETENESS",
              "formula": "‚àÄ c ‚àà ErrorConstraints(S). S ‚ä® c",
              "description": "All error-level constraints are satisfied"
            },
            {
              "type": "paragraph",
              "text": "Formally:\nComplete(S) ‚â° ‚àÄ c ‚àà ErrorConstraints(S). c.œÜ(E, D) = ‚ä§"
            },
            {
              "type": "paragraph",
              "text": "Common completeness constraints:"
            },
            {
              "type": "list",
              "items": [
                "‚àÄ feature f. ‚àÉ test t. tests(t, f) - Feature test coverage",
                "‚àÄ api a. ‚àÉ doc d. documents(d, a) - API documentation",
                "‚àÄ aggregate ag. ‚àÉ command c. commands(ag, c) - Aggregate has commands"
              ]
            }
          ]
        },
        {
          "id": "sec-04-3",
          "number": "4.3",
          "title": "Consistency",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 4.5 (Contradiction)",
              "text": "contradiction(e‚ÇÅ, e‚ÇÇ) ‚â° ‚àÉ property p.\n  e‚ÇÅ.œÄ(p) is defined ‚àß e‚ÇÇ.œÄ(p) is defined ‚àß\n  e‚ÇÅ.œÄ(p) ‚â† e‚ÇÇ.œÄ(p) ‚àß shouldMatch(e‚ÇÅ, e‚ÇÇ, p)"
            },
            {
              "type": "definition",
              "label": "Definition 4.6 (Should Match)",
              "text": "shouldMatch(e‚ÇÅ, e‚ÇÇ, p) ‚â° ‚àÉ c ‚àà C. c.cat = consistency ‚àß c specifies e‚ÇÅ.p must equal e‚ÇÇ.p"
            },
            {
              "type": "guarantee",
              "label": "GUARANTEE G3 - CONSISTENCY",
              "formula": "‚àÄ e‚ÇÅ, e‚ÇÇ ‚àà E. ¬¨contradiction(e‚ÇÅ, e‚ÇÇ)",
              "description": "No two elements have contradictory properties"
            },
            {
              "type": "paragraph",
              "text": "Formally:\nConsistent(S) ‚â° ‚àÄ e‚ÇÅ, e‚ÇÇ ‚àà elements(S). ¬¨contradiction(e‚ÇÅ, e‚ÇÇ)"
            },
            {
              "type": "paragraph",
              "text": "Common consistency constraints:"
            },
            {
              "type": "list",
              "items": [
                "API return type = Handler return type",
                "Event schema = Event handler expected schema",
                "Database field type = Domain entity field type"
              ]
            }
          ]
        },
        {
          "id": "sec-04-4",
          "number": "4.4",
          "title": "Groundedness",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 4.7 (Leaf Element)",
              "text": "leaf(e) ‚â° layer(e).tier = grounding"
            },
            {
              "type": "definition",
              "label": "Definition 4.8 (Bound Element)",
              "text": "bound(e) ‚â° ‚àÉ b ‚àà B. b.abstract.elem = e.id"
            },
            {
              "type": "guarantee",
              "label": "GUARANTEE G4 - GROUNDEDNESS",
              "formula": "‚àÄ e ‚àà E. leaf(e) ‚Üí bound(e)",
              "description": "Every leaf element has a binding to physical reality"
            },
            {
              "type": "paragraph",
              "text": "Formally:\nGrounded(S) ‚â° ‚àÄ e ‚àà elements(S). leaf(e) ‚Üí bound(e)"
            },
            {
              "type": "paragraph",
              "text": "Binding types per domain:"
            },
            {
              "type": "list",
              "items": [
                "Software: Component ‚Üí File:Line",
                "Manufacturing: Part ‚Üí Drawing + BOM",
                "Healthcare: Protocol ‚Üí EMR Configuration",
                "Legal: Clause ‚Üí Document Section"
              ]
            }
          ]
        },
        {
          "id": "sec-04-5",
          "number": "4.5",
          "title": "Determinism",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 4.9 (Change)",
              "text": "Œ¥ ::= ‚ü®element: ID, changeType: CHANGE, details: VALUE‚ü©"
            },
            {
              "type": "definition",
              "label": "Definition 4.10 (Impact)",
              "text": "impact(S, Œ¥) = ‚ãÉ {cascade(S, elem(Œ¥), Œ¥.changeType, r) | r ‚àà R, r.trigger matches Œ¥}"
            },
            {
              "type": "guarantee",
              "label": "GUARANTEE G5 - DETERMINISM",
              "formula": "‚àÄ Œ¥ : CHANGE. impact(S, Œ¥) is computable before applying Œ¥",
              "description": "The impact of any change is predictable before making the change"
            },
            {
              "type": "paragraph",
              "text": "Formally:\nDeterministic(S) ‚â° impact : S √ó CHANGE ‚Üí P(E √ó EFFECT) is total and computable in O(|E| + |D|) time"
            },
            {
              "type": "paragraph",
              "text": "This enables:"
            },
            {
              "type": "list",
              "items": [
                "Pre-change impact analysis",
                "Automated change review",
                "Risk assessment",
                "Staged rollout decisions"
              ]
            }
          ]
        },
        {
          "id": "sec-04-6",
          "number": "4.6",
          "title": "Coherence",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 4.11 (Layer Respecting)",
              "text": "layerRespecting(d) ‚â° let l_s = layer(src(d)), l_t = layer(tgt(d)) in\n  pos(l_s) ‚â• pos(l_t) ‚à® d.Œ¥ = traces_to"
            },
            {
              "type": "guarantee",
              "label": "GUARANTEE G6 - COHERENCE",
              "formula": "‚àÄ d ‚àà D. layerRespecting(d)",
              "description": "Dependencies flow from concrete to abstract (except traces_to)"
            },
            {
              "type": "paragraph",
              "text": "Formally:\nCoherent(S) ‚â° ‚àÄ d ‚àà dependencies(S). layerRespecting(d)"
            },
            {
              "type": "paragraph",
              "text": "This ensures:"
            },
            {
              "type": "list",
              "items": [
                "Abstraction boundaries are respected",
                "Implementation details don't leak upward",
                "Changes cascade predictably (down, not up)"
              ]
            },
            {
              "type": "paragraph",
              "text": "Exception: traces_to dependencies go UP (from impl to requirement)"
            }
          ]
        },
        {
          "id": "sec-04-7",
          "number": "4.7",
          "title": "Explainability [v2.5]",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "When validation fails, humans need actionable explanations. G7 requires that every violation report includes an irreducible unsat core‚Äîthe minimal set of constraints causing the failure‚Äîand human-readable diagnostic text."
            },
            {
              "type": "definition",
              "label": "Definition 4.12 (Explanation)",
              "text": "explanation ::= ‚ü®violatedGuarantee, unsatCore, blameChain, humanReadable, suggestedFix?‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "violatedGuarantee ‚àà {'G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7'}",
                  "definition": "Which guarantee failed"
                },
                {
                  "term": "unsatCore ‚äÜ constraints(S)",
                  "definition": "Minimal unsatisfiable subset (see Theorem 10.12)"
                },
                {
                  "term": "blameChain ‚àà Operation*",
                  "definition": "Causal chain of changes leading to violation (uses vector clocks from ¬ß2.1, ¬ß12)"
                },
                {
                  "term": "humanReadable ‚àà NAME",
                  "definition": "Natural language explanation targeting domain experts"
                },
                {
                  "term": "suggestedFix ‚àà Operation?",
                  "definition": "Optional: automated remediation per Policy (¬ß2.8)"
                }
              ]
            },
            {
              "type": "guarantee",
              "label": "GUARANTEE G7 - EXPLAINABILITY",
              "formula": "‚àÄ violations v from validate(S). ‚àÉ explanation x. explains(x, v) ‚àß irreducible(x.unsatCore)",
              "description": "Every validation failure has an irreducible explanation with minimal unsat core"
            },
            {
              "type": "paragraph",
              "text": "Formally:\nExplainable(S) ‚â° validate(S) produces explanations for all violations"
            },
            {
              "type": "paragraph",
              "text": "**Implementation**: Use SMT solver unsat core extraction (Z3 `unsat_core()`, CVC5 `getUnsatCore()`). See Theorem 10.12 for irreducibility proof obligation."
            },
            {
              "type": "admonition",
              "level": "note",
              "text": "**Conformance**: G7 is **K1 (Certified-Aware)**, not K0. K0 implementations may return violations without explanations. K1+ implementations MUST provide irreducible unsat cores per Theorem 10.12."
            },
            {
              "type": "paragraph",
              "text": "**Example**: See ¬ß1.5 Demo Scenario for complete G7 workflow showing blame chains and suggested fixes."
            }
          ]
        },
        {
          "id": "sec-04-8",
          "number": "4.8",
          "title": "Valid Specification",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 4.13 (Valid Specification)",
              "text": "Valid(S) ‚â° WellFormed(S) ‚àß\n           Traceable(S) ‚àß       -- G1\n           Complete(S) ‚àß        -- G2\n           Consistent(S) ‚àß      -- G3\n           Grounded(S) ‚àß        -- G4\n           Deterministic(S) ‚àß   -- G5\n           Coherent(S) ‚àß        -- G6\n           Explainable(S)       -- G7 [v2.5]"
            },
            {
              "type": "paragraph",
              "text": "A specification is valid iff it is well-formed and satisfies all seven guarantees. Note: G7 (Explainability) is K1 conformance; K0 implementations check G1-G6 only."
            }
          ]
        }
      ]
    },
    {
      "id": "sec-05",
      "number": "5",
      "title": "Type System",
      "defs": [],
      "children": [
        {
          "id": "sec-05-1",
          "number": "5.1",
          "title": "Type Syntax",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Base Types:"
            },
            {
              "type": "code",
              "lines": [
                "œÑ ::= string | number | boolean | null",
                "    | œÑ[]                           -- Array type",
                "    | {p‚ÇÅ: œÑ‚ÇÅ, ..., p‚Çô: œÑ‚Çô}        -- Object type",
                "    | œÑ‚ÇÅ | œÑ‚ÇÇ                       -- Union type",
                "    | œÑ‚ÇÅ & œÑ‚ÇÇ                       -- Intersection type",
                "    | Ref<L, T>                     -- Reference to element of type T in layer L"
              ]
            },
            {
              "type": "paragraph",
              "text": "Element Types:"
            },
            {
              "type": "code",
              "lines": [
                "ElementType<L> ::= {",
                "  id: string,",
                "  type: T where T ‚àà L.T,",
                "  layer: L.id,",
                "  properties: PropertiesOf<T>,",
                "  metadata: Metadata",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "Reference Types:"
            },
            {
              "type": "code",
              "lines": ["Ref<L, T> = { elementId: string, layerId: L.id, expectedType: T }"]
            }
          ]
        },
        {
          "id": "sec-05-2",
          "number": "5.2",
          "title": "Typing Judgments",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Contexts:"
            },
            {
              "type": "code",
              "lines": ["Œì ::= ‚àÖ | Œì, x : œÑ | Œì, l : Layer | Œì, e : Element<L>"]
            },
            {
              "type": "paragraph",
              "text": "Judgments:"
            },
            {
              "type": "code",
              "lines": [
                "Œì ‚ä¢ e : œÑ           -- e has type œÑ in context Œì",
                "Œì ‚ä¢ d : D           -- d is a valid dependency in context Œì",
                "Œì ‚ä¢ c : C           -- c is a valid constraint in context Œì",
                "Œì ‚ä¢ S valid         -- S is a valid specification in context Œì"
              ]
            },
            {
              "type": "rule",
              "label": "T-ELEMENT: Element Typing",
              "formula": "l ‚àà Œì    œÑ ‚àà l.T    Œì ‚ä¢ œÄ : PropertiesOf<œÑ>\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nŒì ‚ä¢ ‚ü®id, œÑ, l.id, œÄ, Œº‚ü© : Element<l>"
            },
            {
              "type": "rule",
              "label": "T-REF: Reference Typing",
              "formula": "Œì ‚ä¢ e : Element<L>    e.œÑ = T\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nŒì ‚ä¢ ref(e) : Ref<L, T>"
            },
            {
              "type": "rule",
              "label": "T-DEP: Dependency Typing",
              "formula": "Œì ‚ä¢ e‚ÇÅ : Element<L‚ÇÅ>    Œì ‚ä¢ e‚ÇÇ : Element<L‚ÇÇ>    validDepType(Œ¥, e‚ÇÅ.œÑ, e‚ÇÇ.œÑ)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nŒì ‚ä¢ ‚ü®id, (e‚ÇÅ.id, L‚ÇÅ), (e‚ÇÇ.id, L‚ÇÇ), Œ¥, œÉ, Œ∫‚ü© : Dependency"
            }
          ]
        },
        {
          "id": "sec-05-3",
          "number": "5.3",
          "title": "Subtyping",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Subtyping Judgment: œÑ‚ÇÅ <: œÑ‚ÇÇ (œÑ‚ÇÅ is a subtype of œÑ‚ÇÇ)"
            },
            {
              "type": "rule",
              "label": "S-REFL: Reflexivity",
              "formula": "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nœÑ <: œÑ"
            },
            {
              "type": "rule",
              "label": "S-TRANS: Transitivity",
              "formula": "œÑ‚ÇÅ <: œÑ‚ÇÇ    œÑ‚ÇÇ <: œÑ‚ÇÉ\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nœÑ‚ÇÅ <: œÑ‚ÇÉ"
            },
            {
              "type": "rule",
              "label": "S-UNION-L: Union Left",
              "formula": "œÑ‚ÇÅ <: œÑ‚ÇÅ | œÑ‚ÇÇ"
            },
            {
              "type": "rule",
              "label": "S-UNION-R: Union Right",
              "formula": "œÑ‚ÇÇ <: œÑ‚ÇÅ | œÑ‚ÇÇ"
            },
            {
              "type": "rule",
              "label": "S-WIDTH: Object Width Subtyping",
              "formula": "{p‚ÇÅ: œÑ‚ÇÅ, ..., p‚Çô: œÑ‚Çô, p‚Çô‚Çä‚ÇÅ: œÑ‚Çô‚Çä‚ÇÅ} <: {p‚ÇÅ: œÑ‚ÇÅ, ..., p‚Çô: œÑ‚Çô}"
            },
            {
              "type": "rule",
              "label": "S-DEPTH: Object Depth Subtyping",
              "formula": "œÑ·µ¢ <: œÑ·µ¢' for all i\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n{p‚ÇÅ: œÑ‚ÇÅ, ..., p‚Çô: œÑ‚Çô} <: {p‚ÇÅ: œÑ‚ÇÅ', ..., p‚Çô: œÑ‚Çô'}"
            },
            {
              "type": "rule",
              "label": "S-ELEMENT: Element Subtyping",
              "formula": "L‚ÇÅ <: L‚ÇÇ    T‚ÇÅ <: T‚ÇÇ\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nElement<L‚ÇÅ, T‚ÇÅ> <: Element<L‚ÇÇ, T‚ÇÇ>"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-06",
      "number": "6",
      "title": "Inference Rules",
      "defs": [],
      "children": [
        {
          "id": "sec-06-1",
          "number": "6.1",
          "title": "Specification Validation",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Well-Formed Specification:"
            },
            {
              "type": "rule",
              "label": "SPEC-WF",
              "formula": "WF-ID(S)  WF-LAYER(S)  WF-TYPE(S)  WF-DEP-ENDPOINTS(S)\nWF-BINDING-SOURCE(S)  WF-LAYER-DEPS(S)  WF-TIER-ORDER(S)\nWF-TIER-COMPLETE(S)  WF-ACYCLIC-LAYERS(S)  WF-ACYCLIC-HARD(S)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nWellFormed(S)"
            },
            {
              "type": "paragraph",
              "text": "Valid Specification:"
            },
            {
              "type": "rule",
              "label": "SPEC-VALID (K0 - Six Guarantees)",
              "formula": "WellFormed(S)  Traceable(S)  Complete(S)  Consistent(S)\nGrounded(S)  Deterministic(S)  Coherent(S)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nValid_K0(S)"
            },
            {
              "type": "rule",
              "label": "SPEC-VALID-K1 (K1+ - Seven Guarantees)",
              "formula": "Valid_K0(S)  Explainable(S)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nValid_K1(S)"
            },
            {
              "type": "admonition",
              "level": "note",
              "text": "**Conformance Levels**: K0 (Kernel) conformance requires G1-G6. K1 (Certified-Aware) adds G7 (Explainability). For backward compatibility, Valid(S) ‚â° Valid_K0(S) unless explicitly stated otherwise."
            }
          ]
        },
        {
          "id": "sec-06-2",
          "number": "6.2",
          "title": "Constraint Satisfaction",
          "defs": [],
          "content": [
            {
              "type": "rule",
              "label": "CONSTR-SAT: Single Constraint Satisfaction",
              "formula": "c.œÜ(elements(S), dependencies(S)) = ‚ä§\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nS ‚ä® c"
            },
            {
              "type": "rule",
              "label": "CONSTR-ALL: All Constraints Satisfaction",
              "formula": "‚àÄ c ‚àà constraints(S). S ‚ä® c\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nS ‚ä® constraints(S)"
            },
            {
              "type": "rule",
              "label": "CONSTR-VIOL: Constraint Violation",
              "formula": "c.œÜ(elements(S), dependencies(S)) = ‚ä•\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nS ‚ä≠ c with message c.msg(elements(S))"
            }
          ]
        },
        {
          "id": "sec-06-3",
          "number": "6.3",
          "title": "Cascade Computation",
          "defs": [],
          "content": [
            {
              "type": "admonition",
              "level": "note",
              "text": "**v2.4 Limitation**: These rules only implement forward direction (d.src ‚Üí d.tgt). The direction and respectBoundary fields from CascadeRule (Definition 2.26) are not yet formalized in the inference rules. See v2.5 Polarity Table proposal for complete formalization."
            },
            {
              "type": "paragraph",
              "text": "Base Case - Direct Impact:"
            },
            {
              "type": "rule",
              "label": "CASCADE-1",
              "formula": "d ‚àà D    d.src.elem = e.id    d.Œ¥ ‚àà r.propagation.depTypes\nd.cascade_boundary ‚â† ‚ä§ ‚à® ¬¨r.propagation.respectBoundary\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n(elem(d.tgt), r.effect.severity(1)) ‚àà cascade(S, e, ch, r)"
            },
            {
              "type": "paragraph",
              "text": "Inductive Case - Transitive Impact:"
            },
            {
              "type": "rule",
              "label": "CASCADE-N",
              "formula": "(e', sev) ‚àà cascade(S, e, ch, r)    d.src.elem = e'.id\nd.Œ¥ ‚àà r.propagation.depTypes    n < r.propagation.maxDepth\nd.cascade_boundary ‚â† ‚ä§ ‚à® ¬¨r.propagation.respectBoundary\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n(elem(d.tgt), r.effect.severity(n+1)) ‚àà cascade(S, e, ch, r)"
            },
            {
              "type": "paragraph",
              "text": "Attenuation:"
            },
            {
              "type": "rule",
              "label": "CASCADE-ATT",
              "formula": "r.effect.attenuates = ‚ä§    severity(n) = s\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nseverity(n+1) = attenuate(s)"
            },
            {
              "type": "code",
              "lines": [
                "where attenuate(breaking) = degraded",
                "      attenuate(degraded) = cosmetic",
                "      attenuate(cosmetic) = ‚ä•",
                "      attenuate(‚ä•) = ‚ä•"
              ]
            }
          ]
        },
        {
          "id": "sec-06-4",
          "number": "6.4",
          "title": "Trace Computation",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Base Case - Root:"
            },
            {
              "type": "rule",
              "label": "TRACE-ROOT",
              "formula": "root(e)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ntrace(e) = [e]"
            },
            {
              "type": "paragraph",
              "text": "Inductive Case - Follow traces_to (impl ‚Üí requirement):"
            },
            {
              "type": "rule",
              "label": "TRACE-STEP",
              "formula": "¬¨root(e)    d.tgt.elem = e.id    d.Œ¥ = traces_to    trace(elem(d.src)) = p\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ntrace(e) = e :: p"
            },
            {
              "type": "paragraph",
              "text": "Trace Path Property:"
            },
            {
              "type": "theorem",
              "label": "Trace Path Property",
              "formula": "trace(e) = [e‚ÇÄ, e‚ÇÅ, ..., e‚Çô] ‚Üí pos(layer(e‚ÇÄ)) ‚â• ... ‚â• pos(layer(e‚Çô))",
              "description": "Trace paths ascend through the abstraction hierarchy (implementation to motivation)"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-07",
      "number": "7",
      "title": "Operations",
      "defs": [],
      "children": [
        {
          "id": "sec-07-1",
          "number": "7.1",
          "title": "Query Operations",
          "defs": [],
          "content": [
            {
              "type": "operation",
              "label": "Operation 7.1: validate",
              "signature": "validate : Specification ‚Üí List<Violation>",
              "semantics": "validate(S) = [ (c, c.msg(E)) | c ‚àà C, S ‚ä≠ c ]"
            },
            {
              "type": "operation",
              "label": "Operation 7.2: trace",
              "signature": "trace : Specification √ó Element ‚Üí List<Element>",
              "semantics": "trace(S, e) = compute trace path from e to root"
            },
            {
              "type": "operation",
              "label": "Operation 7.3: impact",
              "signature": "impact : Specification √ó Change ‚Üí Set<(Element, Effect)>",
              "semantics": "impact(S, Œ¥) = ‚ãÉ { cascade(S, elem(Œ¥), Œ¥.changeType, r) | r ‚àà R, r.trigger matches Œ¥ }"
            },
            {
              "type": "operation",
              "label": "Operation 7.4: coverage",
              "signature": "coverage : Specification √ó Layer ‚Üí CoverageMetrics",
              "semantics": "coverage(S, l) = {\n  total: |{e ‚àà E | e.l = l.id}|,\n  bound: |{e ‚àà E | e.l = l.id ‚àß bound(e)}|,\n  traced: |{e ‚àà E | e.l = l.id ‚àß trace(S,e) ‚â† ‚àÖ}|\n}"
            },
            {
              "type": "operation",
              "label": "Operation 7.5: bind",
              "signature": "bind : Specification √ó Element ‚Üí Option<Artifact>",
              "semantics": "bind(S, e) = if ‚àÉb ‚àà B. b.abstract.elem = e.id then Some(b.concrete) else None"
            }
          ]
        },
        {
          "id": "sec-07-2",
          "number": "7.2",
          "title": "Modification Operations",
          "defs": [],
          "content": [
            {
              "type": "operation",
              "label": "Operation 7.6: addElement",
              "signature": "addElement : Specification √ó Element ‚Üí Result<Specification, Error>",
              "semantics": "addElement(S, e) =\n  let S' = S with E' = E ‚à™ {e}\n  if WellFormed(S') then Ok(S') else Err(violations)"
            },
            {
              "type": "operation",
              "label": "Operation 7.7: addDependency",
              "signature": "addDependency : Specification √ó Dependency ‚Üí Result<Specification, Error>",
              "semantics": "addDependency(S, d) =\n  let S' = S with D' = D ‚à™ {d}\n  if WellFormed(S') ‚àß Coherent(S') then Ok(S') else Err(violations)"
            },
            {
              "type": "operation",
              "label": "Operation 7.8: removeElement",
              "signature": "removeElement : Specification √ó ElementId ‚Üí Result<Specification, Warning>",
              "semantics": "removeElement(S, eid) =\n  let affected = impact(S, ‚ü®eid, delete, {}‚ü©)\n  let S' = S with E' = {e ‚àà E | e.id ‚â† eid},\n                   D' = {d ‚àà D | d.src.elem ‚â† eid ‚àß d.tgt.elem ‚â† eid},\n                   B' = {b ‚àà B | b.abstract.elem ‚â† eid}\n  Ok(S') with warnings about affected"
            }
          ]
        },
        {
          "id": "sec-07-3",
          "number": "7.3",
          "title": "Comparison Operations",
          "defs": [],
          "content": [
            {
              "type": "operation",
              "label": "Operation 7.9: diff",
              "signature": "diff : Specification √ó Specification ‚Üí Set<Change>",
              "semantics": "diff(S‚ÇÅ, S‚ÇÇ) = {\n  added: {e ‚àà S‚ÇÇ.E | e.id ‚àâ ids(S‚ÇÅ.E)},\n  removed: {e ‚àà S‚ÇÅ.E | e.id ‚àâ ids(S‚ÇÇ.E)},\n  modified: {(e‚ÇÅ, e‚ÇÇ) | e‚ÇÅ ‚àà S‚ÇÅ.E, e‚ÇÇ ‚àà S‚ÇÇ.E, e‚ÇÅ.id = e‚ÇÇ.id, e‚ÇÅ ‚â† e‚ÇÇ}\n}"
            },
            {
              "type": "operation",
              "label": "Operation 7.10: merge",
              "signature": "merge : Specification √ó Specification ‚Üí Result<Specification, Conflict>",
              "semantics": "merge(S‚ÇÅ, S‚ÇÇ) =\n  let conflicts = detectConflicts(S‚ÇÅ, S‚ÇÇ)\n  if conflicts = ‚àÖ then\n    Ok(S‚ÇÅ ‚äî S‚ÇÇ)  -- lattice join\n  else\n    Err(conflicts)"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-08",
      "number": "8",
      "title": "Domain Profiles",
      "defs": [],
      "children": [
        {
          "id": "sec-08-1",
          "number": "8.1",
          "title": "Domain Profile Definition",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 8.1 (Domain Profile)",
              "text": "A Domain Profile P is a tuple:\n\nP ::= ‚ü®id, name, layers, depTypes, constraintCats, bindingTypes, cascades‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "id ‚àà ID",
                  "definition": "Unique domain identifier"
                },
                {
                  "term": "name ‚àà NAME",
                  "definition": "Human-readable name"
                },
                {
                  "term": "layers : List<LayerDef>",
                  "definition": "Layer definitions for this domain"
                },
                {
                  "term": "depTypes : List<DepTypeDef>",
                  "definition": "Dependency types for this domain"
                },
                {
                  "term": "constraintCats : List<CatDef>",
                  "definition": "Constraint categories"
                },
                {
                  "term": "bindingTypes : List<BindDef>",
                  "definition": "Binding types for this domain"
                },
                {
                  "term": "cascades : List<CascadeDef>",
                  "definition": "Cascade rules"
                }
              ]
            },
            {
              "type": "definition",
              "label": "Definition 8.2 (Profile Satisfaction)",
              "text": "S satisfies P (written S : P) iff:\n‚Ä¢ S.domain = P.id\n‚Ä¢ ‚àÄ l ‚àà S.L. l conforms to some layer definition in P.layers\n‚Ä¢ ‚àÄ d ‚àà S.D. d.Œ¥ ‚àà P.depTypes\n‚Ä¢ ‚àÄ c ‚àà S.C. c.cat ‚àà P.constraintCats\n‚Ä¢ ‚àÄ b ‚àà S.B. b.concrete.type ‚àà P.bindingTypes"
            }
          ]
        },
        {
          "id": "sec-08-2",
          "number": "8.2",
          "title": "Canonical Domain Profiles",
          "defs": [],
          "content": [
            {
              "type": "profile",
              "label": "Profile 8.1: Software Systems",
              "layers": {
                "motivation": [
                  "Strategy(BusinessDomain, Goal, Metric, Constraint, NFR)",
                  "Intent(Persona, Journey, Feature, AcceptanceCriteria)"
                ],
                "logical": [
                  "Design(Component, Pattern, Token, Layout)",
                  "Domain(BoundedContext, Aggregate, Command, Event)",
                  "Contract(API, Message, Effect, Error)"
                ],
                "realization": [
                  "Persistence(Database, DataLake, Cache, Search)",
                  "Runtime(Config, FeatureFlag, Secret, Permission)",
                  "Operations(Deployment, Pipeline, Observability, SLO)"
                ],
                "grounding": ["Physical(File, Symbol, Line, Repository)"]
              }
            },
            {
              "type": "profile",
              "label": "Profile 8.2: Organizations",
              "layers": {
                "motivation": [
                  "Vision(Mission, Vision, Value, StrategicGoal)",
                  "Objectives(OKR, KPI, Initiative, SuccessMetric)"
                ],
                "logical": [
                  "Structure(Department, Team, Role, Responsibility)",
                  "Process(Workflow, Decision, Approval, Escalation)",
                  "Policy(Policy, Guideline, Standard, Procedure)"
                ],
                "realization": [
                  "Capability(Skill, Tool, System, Resource)",
                  "Execution(Project, Task, Milestone, Deliverable)",
                  "Governance(Committee, Review, Audit, Compliance)"
                ],
                "grounding": ["Artifact(Document, Record, Report, Asset)"]
              }
            },
            {
              "type": "profile",
              "label": "Profile 8.3: Manufacturing",
              "layers": {
                "motivation": [
                  "BusinessCase(ProductGoal, MarketNeed, Constraint, Regulation)",
                  "Requirements(Functional, Performance, Safety, Quality)"
                ],
                "logical": [
                  "Design(Assembly, Subassembly, Part, Interface)",
                  "Process(Operation, Sequence, Tooling, Fixture)",
                  "Quality(Inspection, Test, Tolerance, Specification)"
                ],
                "realization": [
                  "Production(Workstation, Machine, Material, Routing)",
                  "Control(Parameter, Setpoint, Program, Recipe)",
                  "Logistics(Inventory, Supply, Schedule, Capacity)"
                ],
                "grounding": ["Physical(Drawing, BOM, WorkInstruction, Equipment)"]
              }
            }
          ]
        }
      ]
    },
    {
      "id": "sec-09",
      "number": "9",
      "title": "Extension Mechanism",
      "defs": [],
      "children": [
        {
          "id": "sec-09-1",
          "number": "9.1",
          "title": "Extension Types",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 9.1 (Stratum Extension)",
              "text": "A Stratum Extension X is a tuple:\n\nX ::= ‚ü®id, name, placement, schemas, constraints, cascades‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "id ‚àà ID",
                  "definition": "Extension identifier"
                },
                {
                  "term": "name ‚àà NAME",
                  "definition": "Human-readable name"
                },
                {
                  "term": "placement ‚àà PLACEMENT",
                  "definition": "Where to insert in stack"
                },
                {
                  "term": "schemas : TYPE ‚Üí Schema",
                  "definition": "Element type schemas"
                },
                {
                  "term": "constraints : List<Constraint>",
                  "definition": "Additional constraints"
                },
                {
                  "term": "cascades : List<CascadeRule>",
                  "definition": "Additional cascade rules"
                }
              ]
            },
            {
              "type": "definition",
              "label": "Definition 9.2 (Placement)",
              "text": "PLACEMENT = { tier: TIER, after: ID*, before: ID*, parallel: ID* }"
            },
            {
              "type": "definition",
              "label": "Definition 9.3 (Constraint Pack)",
              "text": "A Constraint Pack CP is a tuple:\n\nCP ::= ‚ü®id, name, domain, constraints, requires‚ü©"
            },
            {
              "type": "paragraph",
              "text": "where:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "id ‚àà ID",
                  "definition": "Pack identifier"
                },
                {
                  "term": "name ‚àà NAME",
                  "definition": "Human-readable name"
                },
                {
                  "term": "domain ‚àà NAME",
                  "definition": "Target domain (e.g., \"healthcare\")"
                },
                {
                  "term": "constraints : List<Constraint>",
                  "definition": "Constraints in this pack"
                },
                {
                  "term": "requires : List<ID>",
                  "definition": "Required extensions"
                }
              ]
            }
          ]
        },
        {
          "id": "sec-09-2",
          "number": "9.2",
          "title": "Extension Composition",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 9.4 (Extension Application)",
              "text": "apply : Profile √ó Extension ‚Üí Profile\n\napply(P, X) = P' where:\n  P'.layers = insertLayer(P.layers, X.placement, X.schemas)\n  P'.constraints = P.constraints ‚à™ X.constraints\n  P'.cascades = P.cascades ‚à™ X.cascades"
            },
            {
              "type": "definition",
              "label": "Definition 9.5 (Pack Application)",
              "text": "applyPack : Profile √ó ConstraintPack ‚Üí Profile\n\napplyPack(P, CP) = P' where:\n  P'.constraints = P.constraints ‚à™ CP.constraints"
            },
            {
              "type": "theorem",
              "label": "Theorem 9.1 (Extension Monotonicity)",
              "formula": "If Valid(S) and S : P, then for extension X:\n  either Valid(S) and S : apply(P, X)\n  or ‚àÉ new violations from X.constraints",
              "description": "Extensions can only add constraints, never remove them"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-10",
      "number": "10",
      "title": "Formal Properties and Theorems",
      "defs": [],
      "children": [
        {
          "id": "sec-10-1",
          "number": "10.1",
          "title": "Soundness",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Theorem 10.1 (Type Soundness - PROVEN):"
            },
            {
              "type": "code",
              "lines": ["If Œì ‚ä¢ e : œÑ and e ‚Üí* e' (e evaluates to e'), then Œì ‚ä¢ e' : œÑ"]
            },
            {
              "type": "paragraph",
              "text": "Proof: By progress and preservation. The immutability of e.l (¬ß2.1) ensures that the covariant subtyping rule S-ELEMENT cannot be exploited to violate type safety. This follows the approach of Wright & Felleisen (1994)."
            },
            {
              "type": "paragraph",
              "text": "Theorem 10.2 (Constraint Decidability - PROVEN):"
            },
            {
              "type": "code",
              "lines": [
                "For any constraint c with predicate œÜ in QF_LIA + QF_LRA + QF_UF:",
                "  sat(œÜ) is decidable"
              ]
            },
            {
              "type": "paragraph",
              "text": "Proof: QF_LIA, QF_LRA, and QF_UF are decidable fragments of first-order logic per SMT-LIB 2.6 standard. Decidability of the combination follows from the Nelson-Oppen procedure (1979), as these theories are stably infinite and have disjoint signatures (integer/real arithmetic operators vs uninterpreted functions)."
            },
            {
              "type": "paragraph",
              "text": "Theorem 10.3 (Cascade Termination - PROVEN):"
            },
            {
              "type": "code",
              "lines": [
                "For any well-formed S and any cascade rule r:",
                "  cascade(S, e, ch, r) terminates"
              ]
            },
            {
              "type": "paragraph",
              "text": "Proof: By WF-ACYCLIC-HARD, hard dependency paths are finite. By WF-SOFT-CYCLE-BOUNDED, soft cycles have boundaries. By WF-CASCADE-TERMINATION, unbounded cascades have finite depth. The attenuation function eventually returns ‚ä•, ensuring propagation stops."
            }
          ]
        },
        {
          "id": "sec-10-2",
          "number": "10.2",
          "title": "Convergence",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Theorem 10.4 (Strong Eventual Consistency) [v2.0]:"
            },
            {
              "type": "code",
              "lines": [
                "For any replicas R‚ÇÅ, R‚ÇÇ with seen(R‚ÇÅ) = seen(R‚ÇÇ):",
                "  state(R‚ÇÅ) = state(R‚ÇÇ)"
              ]
            },
            {
              "type": "paragraph",
              "text": "**Proof [Enhanced v2.5]**: The specification lattice (¬ß7.3) forms a join-semilattice (L, ‚äî, ‚äë) with:\n\n**1. Join-semilattice properties**:\n- **Associativity**: (S‚ÇÅ ‚äî S‚ÇÇ) ‚äî S‚ÇÉ = S‚ÇÅ ‚äî (S‚ÇÇ ‚äî S‚ÇÉ)\n  - Elements: Add-wins set union is associative\n  - Dependencies: LWW with vector clocks is associative\n  - Constraints: Priority-based merge is associative (max is associative)\n\n- **Commutativity**: S‚ÇÅ ‚äî S‚ÇÇ = S‚ÇÇ ‚äî S‚ÇÅ\n  - Elements: Set union is commutative\n  - Dependencies: LWW breaks ties deterministically via vector clock total order\n  - Constraints: max(priority‚ÇÅ, priority‚ÇÇ) = max(priority‚ÇÇ, priority‚ÇÅ)\n\n- **Idempotence**: S ‚äî S = S\n  - All component CRDTs (OR-Set for elements, LWW-Register for metadata) are idempotent\n\n**2. CRDT merge equivalence**: merge(S‚ÇÅ, S‚ÇÇ) computes S‚ÇÅ ‚äî S‚ÇÇ by:\n```\nelements(S‚ÇÅ ‚äî S‚ÇÇ) = elements(S‚ÇÅ) ‚à™ elements(S‚ÇÇ)  -- OR-Set merge\ndeps(S‚ÇÅ ‚äî S‚ÇÇ) = lww(deps(S‚ÇÅ), deps(S‚ÇÇ))          -- LWW-Map merge\nconstraints(S‚ÇÅ ‚äî S‚ÇÇ) = priority_max(...)          -- Priority merge\n```\n\n**3. Convergence**: For replicas R‚ÇÅ, R‚ÇÇ:\n- Let ops‚ÇÅ = operations seen by R‚ÇÅ\n- Let ops‚ÇÇ = operations seen by R‚ÇÇ\n- If ops‚ÇÅ = ops‚ÇÇ, then both replicas apply same set of operations\n- Since ‚äî is associative and commutative, any ordering of ops yields same state\n- Therefore state(R‚ÇÅ) = ‚äî(ops‚ÇÅ) = ‚äî(ops‚ÇÇ) = state(R‚ÇÇ)\n\n**4. Strong Eventual Consistency (SEC)**: By Shapiro et al. (2011) CMA theorem:\n- Eventual Delivery: All operations eventually delivered to all replicas\n- Convergence: Replicas with same operations have same state (proven above)\n- Strong Convergence: No coordination needed (merge is deterministic)\n\nTherefore, STRATUM specifications satisfy SEC. ‚àé"
            },
            {
              "type": "paragraph",
              "text": "Theorem 10.5 (Merge Commutativity) [v2.0]:"
            },
            {
              "type": "code",
              "lines": ["merge(merge(S‚ÇÅ, S‚ÇÇ), S‚ÇÉ) = merge(S‚ÇÅ, merge(S‚ÇÇ, S‚ÇÉ))"]
            },
            {
              "type": "paragraph",
              "text": "Proof: Follows from associativity of the join operation (Theorem 7.1)."
            }
          ]
        },
        {
          "id": "sec-10-3",
          "number": "10.3",
          "title": "Decidability",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Theorem 10.6 (Well-Formedness Decidability):"
            },
            {
              "type": "code",
              "lines": ["WellFormed(S) is decidable in O(|E| + |D| + |L|¬≤)"]
            },
            {
              "type": "paragraph",
              "text": "Theorem 10.7 (Validation Decidability):"
            },
            {
              "type": "code",
              "lines": [
                "For constraints in QF_LIA + QF_LRA + QF_UF:",
                "  validate(S) is decidable in O(|C| √ó SMT_complexity)",
                "where SMT_complexity is NP for satisfiability checking."
              ]
            },
            {
              "type": "paragraph",
              "text": "Theorem 10.8 (Cascade Decidability):"
            },
            {
              "type": "code",
              "lines": ["impact(S, Œ¥) is decidable in O(|E| + |D|) using BFS/DFS"]
            },
            {
              "type": "paragraph",
              "text": "Theorem 10.9 (Trace Decidability):"
            },
            {
              "type": "code",
              "lines": ["trace(S, e) is decidable in O(|D|) where |D| is dependency count"]
            }
          ]
        }
      ]
    },
    {
      "id": "sec-11",
      "number": "11",
      "title": "Reference Implementation",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "Reference implementation schemas defined using Zod for runtime type validation."
        },
        {
          "type": "admonition",
          "level": "warning",
          "text": "**Known Issue - Schema Drift [v2.4.4]**: The Zod schemas below represent an earlier version (v1.0) and have NOT been updated to reflect v2.0+ additions. Known discrepancies:\n\n**Metadata**: Formal spec (¬ß2.1) includes `version: VersionVector, actor: ACTOR, clock: CLOCK` (v2.0); Zod has `version: string`, missing actor/clock.\n\n**Dependency** (¬ß2.3): Formal spec includes `cascade_boundary: ùîπ` (v2.0); Zod schema missing this field.\n\n**Constraint** (¬ß2.4): Formal spec includes `priority: ‚Ñï` for conflict resolution (v2.0); Zod schema missing priority.\n\n**Completeness enum**: Formal spec uses `{complete, partial, stub}`; Zod uses `{full, partial, stub}` (naming inconsistency).\n\n**Change types**: Formal spec (¬ß4.5) has `{create, update, delete, deprecate}`; Zod has `{create, modify, delete, rename}` (semantic drift: update‚â†modify, deprecate‚â†rename).\n\n**Impact severity**: Formal spec uses `{‚ä•, cosmetic, degraded, breaking}` (‚ä• = bottom/none); Zod uses `{none, cosmetic, degraded, breaking}` (need explicit ‚ä•‚Üînone equivalence).\n\n**Recommendation**: These schemas should be considered **Tier 3 conformance** (partial implementation) pending full v2.0+ synchronization. For certification purposes, use the formal definitions in ¬ß2-6 as normative."
        },
        {
          "type": "code",
          "language": "typescript",
          "lines": [
            "export const TierSchema = z.enum(['motivation', 'logical', 'realization', 'grounding']);",
            "",
            "export const StatusSchema = z.enum(['draft', 'active', 'deprecated', 'archived']);",
            "",
            "export const MetadataSchema = z.object({",
            "  created: z.string().datetime(),",
            "  updated: z.string().datetime(),",
            "  version: z.string(),",
            "  status: StatusSchema,",
            "});",
            "",
            "export const ElementSchema = z.object({",
            "  id: z.string(),",
            "  type: z.string(),",
            "  layer: z.string(),",
            "  properties: z.record(z.string(), z.any()),",
            "  metadata: MetadataSchema,",
            "});",
            "",
            "export const LayerSchema = z.object({",
            "  id: z.string(),",
            "  name: z.string(),",
            "  tier: TierSchema,",
            "  order: z.number().int().nonnegative(),",
            "  answersQuestion: z.string(),",
            "  elementTypes: z.array(z.string()),",
            "  dependencies: z.array(z.string()),",
            "});",
            "",
            "export const DepTypeSchema = z.enum([",
            "  'realizes', 'requires', 'produces', 'consumes',",
            "  'constrains', 'validates', 'traces_to',",
            "]);",
            "",
            "export const StrengthSchema = z.enum(['hard', 'soft']);",
            "",
            "export const CardinalitySchema = z.enum([",
            "  'one_to_one', 'one_to_many', 'many_to_one', 'many_to_many',",
            "]);",
            "",
            "export const DependencySchema = z.object({",
            "  id: z.string(),",
            "  source: z.object({ elementId: z.string(), layerId: z.string() }),",
            "  target: z.object({ elementId: z.string(), layerId: z.string() }),",
            "  type: DepTypeSchema,",
            "  strength: StrengthSchema,",
            "  cardinality: CardinalitySchema,",
            "});",
            "",
            "export const CategorySchema = z.enum([",
            "  'existence', 'uniqueness', 'completeness', 'consistency',",
            "  'validity', 'dependency', 'ordering', 'coverage', 'alignment', 'boundary',",
            "]);",
            "",
            "export const SeveritySchema = z.enum(['error', 'warning', 'info']);",
            "",
            "export const ConstraintSchema = z.object({",
            "  id: z.string(),",
            "  name: z.string(),",
            "  scope: z.object({",
            "    sourceLayer: z.string().optional(),",
            "    sourceType: z.string().optional(),",
            "    targetLayer: z.string().optional(),",
            "    targetType: z.string().optional(),",
            "  }),",
            "  category: CategorySchema,",
            "  severity: SeveritySchema,",
            "  predicate: z.string(),",
            "  message: z.string(),",
            "});",
            "",
            "export const CompletenessSchema = z.enum(['full', 'partial', 'stub']);",
            "",
            "export const ArtifactSchema = z.object({",
            "  type: z.string(),",
            "  location: z.string(),",
            "  identifier: z.string(),",
            "  properties: z.record(z.string(), z.any()).optional(),",
            "});",
            "",
            "export const BindingSchema = z.object({",
            "  id: z.string(),",
            "  abstract: z.object({ elementId: z.string(), layerId: z.string() }),",
            "  concrete: ArtifactSchema,",
            "  completeness: CompletenessSchema,",
            "  verification: z.object({",
            "    lastVerified: z.string().datetime().optional(),",
            "    method: z.string().optional(),",
            "  }).optional(),",
            "});",
            "",
            "export const ChangeTypeSchema = z.enum(['create', 'modify', 'delete', 'rename']);",
            "",
            "// IMPACT = {‚ä•, cosmetic, degraded, breaking} per Definition 2.25",
            "// Note: '‚ä•' is represented as 'bottom' in JSON/TypeScript for compatibility",
            "export const EffectSeveritySchema = z.enum(['breaking', 'degraded', 'cosmetic', 'bottom']);",
            "",
            "export const DirectionSchema = z.enum(['forward', 'backward', 'both']);",
            "",
            "export const CascadeRuleSchema = z.object({",
            "  id: z.string(),",
            "  trigger: z.object({",
            "    elementType: z.string(),",
            "    changeType: ChangeTypeSchema,",
            "  }),",
            "  propagation: z.object({",
            "    dependencyTypes: z.array(DepTypeSchema),",
            "    direction: DirectionSchema,",
            "    maxDepth: z.number().int().positive().optional(),",
            "  }),",
            "  effect: z.object({",
            "    severity: EffectSeveritySchema,",
            "    action: z.string(),",
            "    attenuates: z.boolean(),",
            "  }),",
            "});",
            "",
            "export const SpecificationSchema = z.object({",
            "  id: z.string(),",
            "  name: z.string(),",
            "  domain: z.string(),",
            "  version: z.string(),",
            "  layers: z.array(LayerSchema),",
            "  elements: z.array(ElementSchema),",
            "  dependencies: z.array(DependencySchema),",
            "  constraints: z.array(ConstraintSchema),",
            "  bindings: z.array(BindingSchema),",
            "  cascadeRules: z.array(CascadeRuleSchema),",
            "  metadata: MetadataSchema,",
            "});"
          ]
        }
      ]
    },
    {
      "id": "sec-13",
      "number": "13",
      "title": "Concurrency Semantics",
      "defs": [],
      "children": [
        {
          "id": "sec-13-1",
          "number": "13.1",
          "title": "Concurrent Modification Model",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "STRATUM supports collaborative specification development via CRDT-based eventual consistency. This section formalizes the concurrency model."
            },
            {
              "type": "definition",
              "label": "Definition 13.1 (Operation)",
              "text": "op ::= ‚ü®id, actor, clock, type, payload‚ü©\n\nOP_TYPE = {\n  add_element(e),\n  remove_element(eid),\n  update_property(eid, prop, value),\n  add_dependency(d),\n  remove_dependency(did),\n  add_constraint(c),\n  update_binding(b)\n}"
            },
            {
              "type": "definition",
              "label": "Definition 13.2 (Causality)",
              "text": "op‚ÇÅ ‚Üí op‚ÇÇ (op‚ÇÅ causally precedes op‚ÇÇ) iff:\n  op‚ÇÅ.clock < op‚ÇÇ.clock\n\nop‚ÇÅ ‚à• op‚ÇÇ (op‚ÇÅ concurrent with op‚ÇÇ) iff:\n  ¬¨(op‚ÇÅ ‚Üí op‚ÇÇ) ‚àß ¬¨(op‚ÇÇ ‚Üí op‚ÇÅ)"
            },
            {
              "type": "definition",
              "label": "Definition 13.3 (Operation Semantics)",
              "text": "apply : Specification √ó Operation ‚Üí Specification"
            },
            {
              "type": "code",
              "lines": [
                "apply(S, op) = case op.type of",
                "  add_element(e) ‚Üí",
                "    if e.id ‚àâ ids(S.E)",
                "    then S with E' = E ‚à™ {e}, H' = H ++ [op]",
                "    else S with E' = E[e.id ‚Ü¶ e ‚äî S.E(e.id)], H' = H ++ [op]",
                "",
                "  remove_element(eid) ‚Üí",
                "    S with",
                "      E' = {e ‚àà E | e.id ‚â† eid ‚à® e.Œº.clock > op.clock},",
                "      H' = H ++ [op]",
                "    -- Add-wins: concurrent add beats remove",
                "",
                "  update_property(eid, prop, value) ‚Üí",
                "    let e = S.E(eid) in",
                "    let e' = e with œÄ' = œÄ[prop ‚Ü¶ (value, op.clock)] in  -- LWW register",
                "    S with E' = E[eid ‚Ü¶ e'], H' = H ++ [op]",
                "",
                "  add_dependency(d) ‚Üí",
                "    S with D' = D ‚à™ {d}, H' = H ++ [op]"
              ]
            }
          ]
        },
        {
          "id": "sec-13-2",
          "number": "13.2",
          "title": "Replica Synchronization",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 13.4 (Replica State)",
              "text": "A replica R is a pair (S, seen) where:\n  S: current specification state\n  seen: set of operation IDs that have been applied"
            },
            {
              "type": "definition",
              "label": "Definition 13.5 (Synchronization)",
              "text": "sync : Replica √ó Replica ‚Üí Replica √ó Replica"
            },
            {
              "type": "code",
              "lines": [
                "sync(R‚ÇÅ, R‚ÇÇ) =",
                "  let new_for_1 = {op ‚àà R‚ÇÇ.H | op.id ‚àâ R‚ÇÅ.seen}",
                "  let new_for_2 = {op ‚àà R‚ÇÅ.H | op.id ‚àâ R‚ÇÇ.seen}",
                "  let R‚ÇÅ' = foldl(apply, R‚ÇÅ.S, causal_sort(new_for_1))",
                "  let R‚ÇÇ' = foldl(apply, R‚ÇÇ.S, causal_sort(new_for_2))",
                "  ((R‚ÇÅ'.S, R‚ÇÅ.seen ‚à™ ids(new_for_1)),",
                "   (R‚ÇÇ'.S, R‚ÇÇ.seen ‚à™ ids(new_for_2)))"
              ]
            },
            {
              "type": "theorem",
              "label": "Theorem 13.1 (Convergence)",
              "formula": "For any two replicas R‚ÇÅ, R‚ÇÇ that have synchronized:\n  R‚ÇÅ.S = R‚ÇÇ.S",
              "description": "All replicas eventually converge to the same state"
            },
            {
              "type": "theorem",
              "label": "Theorem 13.2 (Intention Preservation)",
              "formula": "If op is a local operation on replica R:\n  effect(op) ‚äÜ effect_in_final_state(op)",
              "description": "The intent of an operation is preserved in the final merged state (modulo conflict resolution rules)"
            }
          ]
        },
        {
          "id": "sec-13-3",
          "number": "13.3",
          "title": "Conflict Resolution Policies",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "For concurrent operations on the same entity:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "1. Add-wins (for elements, dependencies)",
                  "definition": "If op‚ÇÅ = add(x) and op‚ÇÇ = remove(x.id) and op‚ÇÅ ‚à• op‚ÇÇ: x is present in final state"
                },
                {
                  "term": "2. Last-Writer-Wins (for properties)",
                  "definition": "If op‚ÇÅ = update(e, p, v‚ÇÅ) and op‚ÇÇ = update(e, p, v‚ÇÇ) and op‚ÇÅ ‚à• op‚ÇÇ: use v_i where op_i.clock is lexicographically greater"
                },
                {
                  "term": "3. Priority-based (for constraints)",
                  "definition": "If conflict(c‚ÇÅ, c‚ÇÇ): if c‚ÇÅ.priority > c‚ÇÇ.priority then apply c‚ÇÅ; else if c‚ÇÇ.priority > c‚ÇÅ.priority then apply c‚ÇÇ; else flag for manual resolution"
                },
                {
                  "term": "4. Union (for cascade rules)",
                  "definition": "All cascade rules from both replicas are kept. Duplicate rules (by id) are merged using LWW."
                }
              ]
            }
          ]
        },
        {
          "id": "sec-13-4",
          "number": "13.4",
          "title": "CRDT Verification",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Verification approaches for CRDT implementations scale with assurance level requirements."
            },
            {
              "type": "table",
              "label": "Verification Approaches by Assurance Level",
              "columns": ["Level", "Verification Approach", "Reference"],
              "rows": [
                [
                  "DAL-A/ASIL-D",
                  "Mechanized proof (Lean/Coq)",
                  "iasakura/lean-yjs (2025), Gomes et al. 2017 (Isabelle)"
                ],
                [
                  "DAL-B/ASIL-C",
                  "Type-system verified, Model checking (TLA+/TLC)",
                  "Zakhour et al. 2023 (PLDI), Cousineau et al. 2012 (FM)"
                ],
                [
                  "DAL-C/ASIL-B",
                  "Property-based testing, Bounded model checking",
                  "QuickCheck/Hypothesis, CBMC"
                ],
                ["DAL-D/ASIL-A", "Unit testing + code review", "Standard practice"]
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "sec-14",
      "number": "14",
      "title": "Binding Verification Lifecycle",
      "defs": [],
      "children": [
        {
          "id": "sec-14-1",
          "number": "14.1",
          "title": "Verification State Machine",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "**Definition 14.1 (Verification State Machine)**"
            },
            {
              "type": "code",
              "language": "text",
              "lines": [
                "                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê",
                "                 ‚îÇ                                         ‚îÇ",
                "                 ‚ñº                                         ‚îÇ",
                "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  initiate  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  success  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ",
                "‚îÇunverified‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ pending ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ verified ‚îÇ‚îÇ",
                "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ",
                "                             ‚îÇ                     ‚îÇ       ‚îÇ",
                "                          failure                change    ‚îÇ",
                "                             ‚îÇ                     ‚îÇ       ‚îÇ",
                "                             ‚ñº                     ‚ñº       ‚îÇ",
                "                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ",
                "                        ‚îÇ failed ‚îÇ           ‚îÇ stale ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
                "                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     retry",
                "                             ‚îÇ                     ‚îÇ",
                "                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
                "                                    retry"
              ]
            },
            {
              "type": "definition",
              "label": "Definition 14.2 (State Transitions)",
              "text": "transition : VERIFICATION √ó EVENT ‚Üí VERIFICATION"
            },
            {
              "type": "code",
              "lines": [
                "transition(unverified, initiate) = pending",
                "transition(pending, success) = verified",
                "transition(pending, failure) = failed",
                "transition(verified, artifact_changed) = stale",
                "transition(stale, initiate) = pending",
                "transition(failed, retry) = pending",
                "",
                "All other combinations return the current state unchanged."
              ]
            }
          ]
        },
        {
          "id": "sec-14-2",
          "number": "14.2",
          "title": "Verification Evidence",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 14.3 (Evidence Record)",
              "text": "evidence ::= ‚ü®\n  id: ID,\n  type: EVIDENCE_TYPE,\n  timestamp: TIME,\n  binding_id: ID,\n  result: ùîπ,\n  confidence: [0, 1],           -- Confidence score\n  details: VALUE,               -- Type-specific details\n  expires_at: TIME*             -- Optional expiration\n‚ü©\n\nEVIDENCE_TYPE = {\n  test_result,        -- Automated test execution\n  static_analysis,    -- Code analysis tool output\n  type_check,         -- Type system verification\n  manual_review,      -- Human review attestation\n  audit_log,          -- Audit trail entry\n  trace_verification, -- Traceability check\n  coverage_report     -- Test coverage data\n}"
            },
            {
              "type": "definition",
              "label": "Definition 14.4 (Verification Decision)",
              "text": "verify : Binding √ó List<Evidence> ‚Üí VERIFICATION"
            },
            {
              "type": "code",
              "lines": [
                "verify(b, evidence) =",
                "  let passing = [e ‚àà evidence | e.result = ‚ä§ ‚àß ¬¨expired(e)]",
                "  let failing = [e ‚àà evidence | e.result = ‚ä• ‚àß ¬¨expired(e)]",
                "  let confidence = Œ£(e.confidence for e in passing) / |passing|",
                "",
                "  if |failing| > 0 then failed",
                "  else if |passing| = 0 then unverified",
                "  else if confidence ‚â• THRESHOLD then verified",
                "  else pending"
              ]
            },
            {
              "type": "definition",
              "label": "Definition 14.5 (Staleness Detection)",
              "text": "isStale : Binding ‚Üí ùîπ\n\nisStale(b) =\n  b.verification = verified ‚àß\n  (b.concrete.hash ‚â† currentHash(b.concrete.uri) ‚à®\n   ‚àÉ e ‚àà evidence(b). expired(e))"
            }
          ]
        },
        {
          "id": "sec-14-3",
          "number": "14.3",
          "title": "Verification Constraints",
          "defs": [],
          "content": [
            {
              "type": "rule",
              "label": "Constraint C-VERIFY-GROUNDING",
              "formula": "‚àÄ e ‚àà E. leaf(e) ‚Üí ‚àÉ b ‚àà B.\n  b.abstract.elem = e.id ‚àß\n  b.verification ‚àà {verified, pending}",
              "description": "Leaf elements must have verified or pending bindings for G4 to hold"
            },
            {
              "type": "rule",
              "label": "Constraint C-VERIFY-FRESH",
              "formula": "‚àÄ b ‚àà B. b.verification = verified ‚Üí\n  ¬¨isStale(b) ‚à® staleness_age(b) < MAX_STALE_DURATION",
              "description": "Verified bindings must not be stale beyond threshold"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-16",
      "number": "16",
      "title": "Schema Evolution",
      "defs": [],
      "overview": "Rules and operations for evolving specification schemas while preserving validity",
      "content": [],
      "children": [
        {
          "id": "sec-16-1",
          "number": "16.1",
          "title": "Evolution Types",
          "defs": [
            {
              "id": "def-evolution-type",
              "kind": "enum",
              "number": "16.1",
              "section": "sec-16-1",
              "name": "EVOLUTION_TYPE",
              "description": "Types of schema evolution",
              "values": ["backward_compatible", "forward_compatible", "full_compatible", "breaking"]
            },
            {
              "id": "def-schema-change",
              "kind": "type",
              "number": "16.2",
              "section": "sec-16-1",
              "name": "SchemaChange",
              "description": "A change to the specification schema",
              "syntax": "change ::= ‚ü®type: CHANGE_TYPE, target: PATH, before: Schema?, after: Schema?, migration: Migration?‚ü©",
              "change_types": [
                "add_field",
                "remove_field",
                "rename_field",
                "change_type",
                "add_constraint",
                "remove_constraint",
                "add_layer",
                "remove_layer",
                "add_element_type",
                "deprecate_element_type"
              ]
            }
          ],
          "overview": "Categories of schema changes",
          "content": []
        },
        {
          "id": "sec-16-2",
          "number": "16.2",
          "title": "Compatibility Rules",
          "defs": [
            {
              "id": "rule-backward-compat",
              "kind": "rule",
              "number": "BACKWARD-COMPAT",
              "section": "sec-16-2",
              "name": "Backward Compatibility",
              "description": "Old data can be read by new schema",
              "label": "BACKWARD-COMPAT",
              "premises": [],
              "conclusion": "‚àÄ S : Schema_old. parse(serialize(S), Schema_new) succeeds",
              "compatible_changes": [
                "add_optional_field",
                "add_field_with_default",
                "widen_type",
                "add_enum_value"
              ]
            },
            {
              "id": "rule-forward-compat",
              "kind": "rule",
              "number": "FORWARD-COMPAT",
              "section": "sec-16-2",
              "name": "Forward Compatibility",
              "description": "New data can be read by old schema",
              "label": "FORWARD-COMPAT",
              "premises": [],
              "conclusion": "‚àÄ S : Schema_new. parse(serialize(S), Schema_old) succeeds",
              "compatible_changes": ["add_optional_field (ignored)", "remove_optional_field"]
            },
            {
              "id": "rule-breaking-change",
              "kind": "rule",
              "number": "BREAKING-CHANGE",
              "section": "sec-16-2",
              "name": "Breaking Change",
              "description": "Changes that break compatibility",
              "label": "BREAKING-CHANGE",
              "premises": [],
              "conclusion": "‚àÉ S : Schema_old. parse(serialize(S), Schema_new) fails",
              "breaking_changes": [
                "remove_required_field",
                "narrow_type",
                "remove_enum_value",
                "change_field_type_incompatibly",
                "add_required_constraint"
              ]
            }
          ],
          "overview": "Rules for determining compatibility",
          "content": []
        },
        {
          "id": "sec-16-3",
          "number": "16.3",
          "title": "Migration Operations",
          "defs": [
            {
              "id": "def-migration",
              "kind": "type",
              "number": "16.3",
              "section": "sec-16-3",
              "name": "Migration",
              "description": "A data migration script",
              "syntax": "migration ::= ‚ü®id: ID, from_version: VERSION, to_version: VERSION, transforms: List<Transform>, reversible: ùîπ‚ü©"
            },
            {
              "id": "def-transform",
              "kind": "type",
              "number": "16.4",
              "section": "sec-16-3",
              "name": "Transform",
              "description": "A single transformation operation",
              "syntax": "transform ::= ‚ü®type: TRANSFORM_TYPE, path: PATH, expression: EXPR‚ü©",
              "transform_types": [
                "set_default",
                "copy_field",
                "rename_field",
                "compute_field",
                "drop_field",
                "split_field",
                "merge_fields"
              ]
            },
            {
              "id": "op-migrate",
              "kind": "function",
              "number": "16.5",
              "section": "sec-16-3",
              "name": "migrate",
              "description": "Migrate specification to new schema version",
              "signature": "migrate : Specification √ó Migration ‚Üí Result<Specification, MigrationError>"
            },
            {
              "id": "thm-migration-validity",
              "kind": "theorem",
              "number": "16.1",
              "section": "sec-16-3",
              "name": "Migration Validity Preservation",
              "description": "Valid specifications remain valid after migration",
              "conclusion": "If Valid(S) under Schema_old and migration is sound, then Valid(migrate(S, migration)) under Schema_new",
              "category": "preservation",
              "proof_sketch": "**Proof Sketch [v2.5]**: By structural induction on the migration transform list.\n\n**Base case**: Empty transform list. migrate(S, ‚ü®‚àÖ‚ü©) = S. Since Valid(S) under Schema_old and Schema_old = Schema_new (no changes), Valid(S) under Schema_new. ‚úì\n\n**Inductive case**: Transform list t‚ÇÅ::ts. Assume Valid(S) and migration is sound.\n\n1. **Well-formedness preservation**: Each transform type preserves WF-rules:\n   - `set_default`: Adds values to existing elements ‚Üí preserves WF-ID, WF-LAYER, WF-ACYCLIC\n   - `rename_field`: Bijective renaming ‚Üí preserves all structural properties\n   - `compute_field`: Pure function of existing data ‚Üí preserves dependencies\n   - `drop_field`: Removal never violates WF-rules (may violate constraints)\n   - `copy_field`, `split_field`, `merge_fields`: Preserve element count and dependency graph\n\n2. **Guarantee preservation**: Migration soundness requires:\n   - G1 (Traceability): Transform cannot remove traces_to edges ‚Üí preserved\n   - G2 (Completeness): New error constraints satisfied by construction (migration transforms ensure this)\n   - G3 (Consistency): Transforms compute consistent values (no contradictions introduced)\n   - G4 (Groundedness): Bindings preserved or migrated with evidence\n   - G5 (Determinism): Cascade rules updated consistently\n   - G6 (Coherence): Layer positions unchanged ‚Üí dependency directions preserved\n   - G7 (Explainability): Unsat cores re-computed for new schema\n\n3. **Constraint compatibility**:\n   - Backward-compatible: Old constraints still valid (new fields optional or have defaults)\n   - Forward-compatible: New constraints don't reference removed fields\n   - Breaking changes: Migration MUST provide transforms that satisfy new required constraints\n\n**Migration soundness criterion**: A migration is sound iff:\n```\n‚àÄ transform ‚àà migration.transforms.\n  transform preserves WellFormed(S) ‚àß\n  transform preserves {G1, G2, G3, G4, G5, G6} ‚àß\n  (transform.type = add_field ‚áí ‚àÉ default_value) ‚àß\n  (transform.type = remove_field ‚áí field not referenced in constraints)\n```\n\n**Termination**: Migration applies finite transform list sequentially in O(|transforms| √ó |E|) time.\n\nTherefore, Valid(S) ‚àß Sound(migration) ‚áí Valid(migrate(S, migration)). ‚àé"
            }
          ],
          "overview": "Data migration during evolution",
          "content": []
        }
      ]
    },
    {
      "id": "sec-17",
      "number": "17",
      "title": "Certification Artifacts",
      "defs": [],
      "children": [
        {
          "id": "sec-17-1",
          "number": "17.1",
          "title": "Requirements Traceability Matrix (RTM)",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 17.1 (RTM Export)",
              "text": "generateRTM : Specification ‚Üí RTMDocument"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "RTMDocument = {",
                "  metadata: {",
                "    specificationId: ID,",
                "    generatedAt: TIME,",
                "    generatorVersion: String,",
                "    standard: DO-178C | ISO-26262 | ASPICE",
                "  },",
                "  matrix: List<RTMRow>",
                "}",
                "",
                "RTMRow = {",
                "  -- Requirement (motivation/logical tier)",
                "  requirementId: ID,",
                "  requirementText: String,",
                "  requirementIntegrity: IntegrityLevel,",
                "  safetyGoals: List<ID>,              -- ISO 26262: linked hazards",
                "",
                "  -- Design (logical/realization tier)",
                "  designElements: List<{",
                "    id: ID,",
                "    type: String,",
                "    traceType: realizes | derives | constrains",
                "  }>,",
                "",
                "  -- Implementation (realization/grounding tier)",
                "  implementations: List<{",
                "    artifactUri: String,",
                "    artifactType: source_code | binary | config,",
                "    bindingCompleteness: complete | partial | stub,",
                "    lastVerified: TIME",
                "  }>,",
                "",
                "  -- Verification",
                "  testCases: List<{",
                "    id: ID,",
                "    type: unit | integration | system | acceptance,",
                "    result: pass | fail | not_run,",
                "    coverage: Number,",
                "    lastRun: TIME",
                "  }>,",
                "",
                "  -- Verification evidence summary",
                "  verificationStatus: VerificationState,",
                "  reviewRecords: List<ReviewRecordSummary>,",
                "  evidenceSummary: {",
                "    totalEvidence: Number,",
                "    passingEvidence: Number,",
                "    averageConfidence: Number,",
                "    lastEvidenceDate: TIME",
                "  }",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "Export formats: CSV, PDF, DOORS-XML, ReqIF"
            }
          ]
        },
        {
          "id": "sec-17-2",
          "number": "17.2",
          "title": "Review Checklists",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 17.2 (Checklist Generation)",
              "text": "generateChecklist : Element √ó Standard √ó IntegrityLevel ‚Üí Checklist"
            },
            {
              "type": "paragraph",
              "text": "DO-178C Checklists by DAL:"
            },
            {
              "type": "checklist",
              "label": "DAL_A (Level A - Catastrophic)",
              "items": [
                "Software Requirements Standards compliance",
                "Requirements traceability to system requirements",
                "Requirements accuracy and consistency",
                "Algorithm correctness verification",
                "MC/DC structural coverage achieved",
                "Data coupling and control coupling analysis",
                "Stack analysis completed",
                "Timing analysis completed",
                "Source code to object code traceability",
                "Tool qualification evidence complete",
                "Independence requirements satisfied",
                "Problem reports addressed"
              ]
            },
            {
              "type": "checklist",
              "label": "DAL_B (Level B - Hazardous)",
              "items": [
                "Software Requirements Standards compliance",
                "Requirements traceability to system requirements",
                "Requirements accuracy and consistency",
                "Decision coverage achieved",
                "Data coupling analysis",
                "Tool qualification evidence complete",
                "Problem reports addressed"
              ]
            },
            {
              "type": "checklist",
              "label": "DAL_C (Level C - Major)",
              "items": [
                "Software Requirements Standards compliance",
                "Requirements traceability",
                "Statement coverage achieved",
                "Problem reports addressed"
              ]
            },
            {
              "type": "checklist",
              "label": "DAL_D/E (Level D/E - Minor/No Effect)",
              "items": ["Basic requirements review", "Functional testing completed"]
            }
          ]
        },
        {
          "id": "sec-17-3",
          "number": "17.3",
          "title": "Change Impact Analysis",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 17.3 (Change Impact Analysis Report)",
              "text": "analyzeChangeImpact : Specification √ó Change ‚Üí ImpactReport"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "Change = {",
                "  type: create | update | delete | deprecate,",
                "  elementId: ID,",
                "  previousState: Element?,",
                "  newState: Element?,",
                "  changedFields: List<String>,",
                "  changeRationale: String,",
                "  changeAuthor: Actor,",
                "  changeTimestamp: TIME",
                "}",
                "",
                "ImpactReport = {",
                "  metadata: { changeId: ID, analysisTimestamp: TIME, analyzerVersion: String },",
                "  changedElement: { id, type, layer, integrity, changeType, changedFields },",
                "  directImpacts: List<{ elementId, dependencyType, impactSeverity, integrity, affectedProperties, requiredActions }>,",
                "  transitiveImpacts: List<{ elementId, pathFromChange, pathLength, attenuatedSeverity, integrity }>,",
                "  criticalImpacts: List<{ elementId, integrity, impactSeverity, requiresReview, requiredReviewers }>,",
                "  verificationImpact: { bindingsInvalidated, evidenceExpired, reviewsRequired, testsToRerun },",
                "  summary: { totalElementsAffected, criticalElementsAffected, maxIntegrityAffected, estimatedReviewHours, riskAssessment }",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "Risk Assessment Calculation:\n  critical: Any ASIL_D/DAL_A element with severity ‚â• degraded\n  high: Any ASIL_C/DAL_B element with severity ‚â• degraded\n  medium: Any ASIL_B/DAL_C element with severity = breaking\n  low: All other cases"
            }
          ]
        },
        {
          "id": "sec-17-4",
          "number": "17.4",
          "title": "Formal Proof Artifacts",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "For DAL_A / ASIL_D certification, formal proofs are REQUIRED in the package."
            },
            {
              "type": "paragraph",
              "text": "**Definition 17.4 (Proof Artifact)**"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "ProofArtifact = {",
                "  id: ID,",
                "  theorem: String,               -- Informal statement",
                "  formalStatement: String,       -- In proof assistant syntax",
                "  prover: coq | lean | isabelle | tlaplus | dafny,",
                "  proofStatus: complete | partial | admitted,",
                "  sourceFile: URI,               -- Path to proof file",
                "  checkedAt: TIME,",
                "  checkedBy: String,             -- Proof checker version",
                "  dependencies: List<ID>,        -- Other theorems used",
                "  assumptions: List<String>,     -- Axioms/admits",
                "  coverage: {",
                "    specificationElements: List<ID>,  -- Elements this proof covers",
                "    constraints: List<ID>,            -- Constraints this proof validates",
                "    wellFormedness: List<String>      -- WF rules this proof validates",
                "  }",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "Required Proofs for STRATUM Certification:"
            },
            {
              "type": "list",
              "items": [
                "1. type_soundness.v (Coq) - Progress + Preservation for Element<L,T>",
                "2. cascade_termination.tla (TLA+) - cascade(S, e, ch, r) terminates for well-formed S",
                "3. crdt_convergence.lean (Lean) - Strong Eventual Consistency for composed CRDT",
                "4. constraint_decidability.dfy (Dafny) - sat(œÜ) is decidable for œÜ in QF-LIRA+EUF",
                "5. attenuation_properties.v (Coq) - Absorption, Monotonicity, Anti-monotonicity, Soft-faster, Bottom"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "sec-18",
      "number": "18",
      "title": "Tool Qualification Guidance (DO-330)",
      "defs": [],
      "children": [
        {
          "id": "sec-18-1",
          "number": "18.1",
          "title": "Tool Qualification Levels (TQL)",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "DO-330 defines Tool Qualification Levels based on tool impact:"
            },
            {
              "type": "paragraph",
              "text": "**Definition 18.1 (Tool Categories)**"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "CRITERIA 1",
                  "definition": "Tool output is part of airborne software. Output directly becomes part of the certified system. Example: Code generator"
                },
                {
                  "term": "CRITERIA 2",
                  "definition": "Tool automates verification AND could fail to detect error. Tool replaces human verification activity. False negative possible (miss a defect). Example: Static analyzer, test coverage tool"
                },
                {
                  "term": "CRITERIA 3",
                  "definition": "Tool automates verification AND cannot fail to detect error. Tool output verified by other means. Example: Test execution framework with manual review"
                }
              ]
            },
            {
              "type": "paragraph",
              "text": "**Definition 18.2 (Tool Qualification Level)**"
            },
            {
              "type": "table",
              "columns": ["Criteria Met", "DAL A", "DAL B", "DAL C", "DAL D"],
              "rows": [
                ["1", "TQL-1", "TQL-2", "TQL-3", "TQL-4"],
                ["2", "TQL-4", "TQL-4", "TQL-5", "TQL-5"],
                ["3", "TQL-5", "TQL-5", "TQL-5", "TQL-5"]
              ]
            },
            {
              "type": "paragraph",
              "text": "TQL Effort:\n  TQL-1: Highest (equivalent to DAL-A software)\n  TQL-2: High (equivalent to DAL-B software)\n  TQL-3: Medium (equivalent to DAL-C software)\n  TQL-4: Low (equivalent to DAL-D software)\n  TQL-5: Lowest (operational history may suffice)"
            }
          ]
        },
        {
          "id": "sec-18-2",
          "number": "18.2",
          "title": "STRATUM Tool Classification",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "STRATUM tools are classified as follows:"
            },
            {
              "type": "table",
              "columns": ["STRATUM Component", "Criteria", "TQL (DAL-A)", "Rationale"],
              "rows": [
                ["Specification Store", "1", "TQL-1", "Stores certified reqs"],
                ["RTM Generator", "2", "TQL-4", "Could miss trace gaps"],
                ["Constraint Validator", "2", "TQL-4", "Could miss violations"],
                ["Impact Analyzer", "2", "TQL-4", "Could miss dependencies"],
                ["Checklist Generator", "3", "TQL-5", "Human reviews output"],
                ["Visualization", "3", "TQL-5", "No certification impact"]
              ]
            },
            {
              "type": "paragraph",
              "text": "**Definition 18.3 (Tool Operational Requirements)**"
            },
            {
              "type": "paragraph",
              "text": "For TQL-1 (Specification Store):"
            },
            {
              "type": "checklist",
              "label": "1. TOOL REQUIREMENTS (DO-330 ¬ß4.2)",
              "items": [
                "Functional requirements documented",
                "Performance requirements documented",
                "Interface requirements documented",
                "Safety requirements derived from system"
              ]
            },
            {
              "type": "checklist",
              "label": "2. TOOL DESIGN (DO-330 ¬ß4.3)",
              "items": [
                "Architecture documented",
                "Low-level design documented",
                "Design traceable to requirements"
              ]
            },
            {
              "type": "checklist",
              "label": "3. TOOL VERIFICATION (DO-330 ¬ß4.4)",
              "items": [
                "Reviews per requirements",
                "Test cases traceable to requirements",
                "MC/DC coverage for DAL-A equivalent",
                "Robustness testing (invalid inputs)"
              ]
            },
            {
              "type": "checklist",
              "label": "4. TOOL QUALIFICATION DATA (DO-330 ¬ß4.5)",
              "items": [
                "Tool Qualification Plan",
                "Tool Requirements",
                "Tool Design Description",
                "Tool Verification Cases and Procedures",
                "Tool Verification Results",
                "Tool Configuration Index",
                "Tool Accomplishment Summary"
              ]
            }
          ]
        },
        {
          "id": "sec-18-3",
          "number": "18.3",
          "title": "Qualification Evidence Templates",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Tool Qualification Plan Template:"
            },
            {
              "type": "code",
              "lines": [
                "1. INTRODUCTION",
                "   1.1 Purpose",
                "   1.2 Scope",
                "   1.3 Tool Identification (name, version, vendor)",
                "",
                "2. TOOL OVERVIEW",
                "   2.1 Tool Function",
                "   2.2 Tool Category (Criteria 1/2/3)",
                "   2.3 Tool Qualification Level",
                "   2.4 Justification",
                "",
                "3. QUALIFICATION ACTIVITIES",
                "   3.1 Requirements Activities",
                "   3.2 Design Activities (if TQL-1/2/3)",
                "   3.3 Verification Activities",
                "   3.4 Configuration Management",
                "",
                "4. QUALIFICATION DELIVERABLES",
                "   4.1 Document List",
                "   4.2 Delivery Schedule",
                "",
                "5. REFERENCES",
                "   5.1 DO-330 Section References",
                "   5.2 Project Standards"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "sec-19",
      "number": "19",
      "title": "Mechanized Proof Templates",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "This section provides proof templates for mechanizing STRATUM guarantees in theorem provers."
        },
        {
          "type": "heading",
          "level": 2,
          "text": "¬ß19.1 TLA+ Cascade Termination Template"
        },
        {
          "type": "code",
          "language": "tla+",
          "lines": [
            "--------------------------- MODULE CascadeTermination ---------------------------",
            "(* STRATUM Cascade Termination Proof",
            " * Proves: cascade(S, e, ch, r) terminates for well-formed specifications",
            " *)",
            "",
            "EXTENDS Naturals, FiniteSets, Sequences",
            "",
            "CONSTANTS",
            "    Elements,           \\* Set of element IDs",
            "    MaxHardPathLength,  \\* = 6 (from attenuation function)",
            "    MaxSoftPathLength   \\* = 2 (from attenuation function)",
            "",
            "VARIABLES",
            "    visited,            \\* Set of visited elements",
            "    queue,              \\* Propagation queue",
            "    impact,             \\* Current impact level per element",
            "    terminated          \\* Termination flag",
            "",
            "\\* Impact levels as numbers: 0=bottom, 1=cosmetic, 2=degraded, 3=breaking",
            "ImpactLevels == 0..3",
            "",
            "\\* Attenuation function (hard dependencies, decay rate 0.5)",
            "AttenuateHard(i, d) ==",
            "    LET decayed == i - (d \\div 2)",
            "    IN IF decayed < 0 THEN 0 ELSE decayed",
            "",
            "\\* Attenuation function (soft dependencies, decay rate 1.5)",
            "AttenuateSoft(i, d) ==",
            "    LET decayed == i - ((3 * d) \\div 2)",
            "    IN IF decayed < 0 THEN 0 ELSE decayed",
            "",
            "\\* THEOREM: Cascade always terminates",
            "\\* Proof strategy:",
            "\\*   1. visited grows monotonically",
            "\\*   2. Elements is finite",
            "\\*   3. Impact decreases via attenuation",
            "\\*   4. When impact = 0, element not added to queue",
            "THEOREM CascadeTerminates ==",
            "    Spec => <>(terminated = TRUE)",
            "",
            "============================================================================="
          ]
        },
        {
          "type": "heading",
          "level": 2,
          "text": "¬ß19.2 Coq Type Soundness Template"
        },
        {
          "type": "code",
          "language": "coq",
          "lines": [
            "(* STRATUM Type Soundness Proof",
            " * Proves: Progress + Preservation for Element<L,T> with INV-1..5",
            " * Based on RustBelt methodology (Jung et al., POPL 2018)",
            " *)",
            "",
            "Require Import Coq.Lists.List.",
            "Require Import Coq.Sets.Ensembles.",
            "Require Import Coq.Logic.Classical_Prop.",
            "",
            "(** * Core Definitions *)",
            "",
            "(** Immutability predicate *)",
            "Definition Immutable (T : Type) :=",
            "  forall (x y : T) (f : T -> T), f x = x.",
            "",
            "(** Layer type - must be immutable *)",
            "Parameter Layer : Type.",
            "Axiom layer_immutable : Immutable Layer.",
            "",
            "(** Main theorems *)",
            "Theorem progress : forall e : Element, well_typed e -> can_step e \\/ is_value e.",
            "Theorem preservation : forall e e', well_typed e -> step e e' -> well_typed e'."
          ]
        },
        {
          "type": "heading",
          "level": 2,
          "text": "¬ß19.3 Lean 4 CRDT Convergence Template"
        },
        {
          "type": "code",
          "language": "lean",
          "lines": [
            "/- STRATUM CRDT Convergence Proof",
            " - Proves: Strong Eventual Consistency for composed CRDT",
            " - Based on Gomes et al. 2017 (OOPSLA) methodology",
            " -/",
            "",
            "import Mathlib.Data.Finset.Basic",
            "import Mathlib.Order.Lattice",
            "",
            "/-- Version vector for causality tracking --/",
            "structure VersionVector where",
            "  clocks : Actor ‚Üí Nat",
            "",
            "/-- Element state as CRDT --/",
            "structure ElementCRDT where",
            "  id : String",
            "  properties : PropertyMap",
            "  version : VersionVector",
            "",
            "/-- Main theorem: Strong Eventual Consistency --/",
            "theorem strong_eventual_consistency :",
            "  ‚àÄ (r1 r2 : Replica),",
            "    received r1 = received r2 ‚Üí",
            "    state r1 = state r2 := by",
            "  sorry -- Proof via ACI properties"
          ]
        }
      ]
    },
    {
      "id": "sec-20",
      "number": "20",
      "title": "Per-Language INV-1..5 Implementation Checklists",
      "defs": [],
      "children": [
        {
          "id": "sec-20-1",
          "number": "20.1",
          "title": "Rust Checklist (Tier 1 - Provably Sound)",
          "defs": [],
          "content": [
            {
              "type": "checklist",
              "label": "INV-1 DEEP IMMUTABILITY",
              "items": [
                "Create #[derive(Immutable)] proc-macro that checks: No Cell<T> fields, No RefCell<T> fields, No UnsafeCell<T> fields, No Arc<Mutex<T>> or Arc<RwLock<T>> fields, All nested types also derive Immutable",
                "Compile-time error if interior mutability detected",
                "Test: Verify Cell<Layer> fails to compile"
              ]
            },
            {
              "type": "checklist",
              "label": "INV-2 CONSTRUCTION ATOMICITY",
              "items": [
                "Make Element::new() private (pub(crate) or private)",
                "Provide ElementBuilder with pub fn build() -> Result<Arc<Element>, Error>",
                "Builder validates all fields before construction",
                "Never return &Element during construction",
                "Test: Verify partial construction is impossible"
              ]
            },
            {
              "type": "checklist",
              "label": "INV-3 REFLECTION/FFI PROHIBITION",
              "items": [
                "Add #![forbid(unsafe_code)] to crate root",
                "No std::mem::transmute anywhere in codebase",
                "No std::ptr operations on Element or Layer",
                "Audit all dependencies for unsafe that touches Element",
                "CI check: cargo deny check unsafe"
              ]
            },
            {
              "type": "checklist",
              "label": "INV-4 SERIALIZATION INTEGRITY",
              "items": [
                "Implement custom Serialize/Deserialize (not #[derive])",
                "Include layer hash in serialized form: let hash = blake3::hash(&layer.canonical_bytes());",
                "Verify hash on deserialization, reject if mismatch",
                "Test: Tampered serialized data rejected",
                "Test: Round-trip e == deserialize(serialize(e))"
              ]
            },
            {
              "type": "checklist",
              "label": "INV-5 THREAD-SAFE PUBLICATION",
              "items": [
                "Element implements Send + Sync",
                "Builder returns Arc<Element>, never raw Element",
                "Use crossbeam::scope for structured concurrency",
                "No &mut Element after construction",
                "Test: Concurrent read access from multiple threads",
                "Test: MIRI for undefined behavior detection"
              ]
            }
          ]
        },
        {
          "id": "sec-20-2",
          "number": "20.2",
          "title": "Kotlin Checklist (Tier 2 - Compile-Time Contracts + Assertions)",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "**Tier 2 Verification Approach**: Kotlin relies primarily on **compile-time contracts** (require(), check(), Kotlin Contracts KEEP) and conventional assertions, NOT formal runtime monitors. JetBrains states: \"There are no plans on bringing [contracts] to the run-time in the near future.\" Standard assert() is disabled by default on JVM. Research exists for coroutine monitoring (Springer 2022) and ESBMC-Jimple model checking (ISSTA 2022), but these are not production-standard runtime verification tools."
            },
            {
              "type": "checklist",
              "label": "INV-1 DEEP IMMUTABILITY",
              "items": [
                "Use data class with val-only properties",
                "Add @Immutable annotation (custom or from Compose)",
                "Configure detekt/ktlint rule to reject var in Layer",
                "Runtime check: reflectively verify no mutable fields",
                "All collection properties use List (not MutableList)",
                "Test: Verify modification attempts throw at runtime"
              ]
            },
            {
              "type": "checklist",
              "label": "INV-2 CONSTRUCTION ATOMICITY",
              "items": [
                "Private constructor: private constructor()",
                "Companion object factory: companion object { fun create(...): Element }",
                "Validation in init block before any property access",
                "No 'this' escape during construction",
                "Test: Partially constructed object cannot be observed"
              ]
            },
            {
              "type": "checklist",
              "label": "INV-3 REFLECTION/FFI PROHIBITION",
              "items": [
                "Use sealed class/interface for Layer hierarchy",
                "Add @JvmSynthetic to prevent Java reflection access",
                "Module-info.java: no opens for element package",
                "Security manager (if available): block setAccessible on Layer",
                "ProGuard/R8 rules to obfuscate internal structure"
              ]
            }
          ]
        },
        {
          "id": "sec-20-3",
          "number": "20.3",
          "title": "TypeScript Checklist (Tier 3 - Convention Enforced)",
          "defs": [],
          "content": [
            {
              "type": "checklist",
              "label": "INV-1 DEEP IMMUTABILITY",
              "items": [
                "Use readonly modifiers on all properties",
                "Use Readonly<T> for object properties",
                "Use ReadonlyArray<T> for array properties",
                "ESLint rule: prefer-readonly-parameter-types",
                "ESLint rule: no-object-mutation (from eslint-plugin-functional)",
                "Use Object.freeze() at runtime for defense-in-depth"
              ]
            },
            {
              "type": "checklist",
              "label": "INV-2 CONSTRUCTION ATOMICITY",
              "items": [
                "Private constructor: private constructor() {}",
                "Static factory: static create(...): Result<Element, ValidationError>",
                "Use zod or io-ts for runtime validation in factory",
                "Factory returns Readonly<Element>",
                "No 'this' passed to callbacks during construction"
              ]
            },
            {
              "type": "checklist",
              "label": "INV-3 REFLECTION PROHIBITION",
              "items": [
                "ESLint rule: no-prototype-builtins",
                "No Object.defineProperty on Element or Layer",
                "No Proxy wrapping of core types",
                "Freeze prototypes: Object.freeze(Element.prototype)"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "sec-21",
      "number": "21",
      "title": "Compositional Semantics",
      "defs": [],
      "children": [
        {
          "id": "sec-21-1",
          "number": "21.1",
          "title": "Specification Combination (S‚ÇÅ + S‚ÇÇ)",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 21.1 (Specification Composition)",
              "text": "Given specifications S‚ÇÅ and S‚ÇÇ, their composition S‚ÇÅ + S‚ÇÇ is defined as:"
            },
            {
              "type": "code",
              "lines": [
                "S‚ÇÅ + S‚ÇÇ = ‚ü®",
                "  id:          fresh_id(),",
                "  name:        S‚ÇÅ.name ++ \" + \" ++ S‚ÇÇ.name,",
                "  domain:      S‚ÇÅ.domain ‚à™ S‚ÇÇ.domain,",
                "  version:     S‚ÇÅ.version ‚äî S‚ÇÇ.version,        -- Vector clock join",
                "  layers:      mergeLayers(S‚ÇÅ.layers, S‚ÇÇ.layers),",
                "  elements:    mergeElements(S‚ÇÅ.elements, S‚ÇÇ.elements),",
                "  dependencies: mergeDeps(S‚ÇÅ.dependencies, S‚ÇÇ.dependencies),",
                "  constraints: mergeConstraints(S‚ÇÅ.constraints, S‚ÇÇ.constraints),",
                "  bindings:    mergeBindings(S‚ÇÅ.bindings, S‚ÇÇ.bindings),",
                "  cascadeRules: mergeCascades(S‚ÇÅ.cascadeRules, S‚ÇÇ.cascadeRules),",
                "  metadata:    mergeMetadata(S‚ÇÅ.metadata, S‚ÇÇ.metadata)",
                "‚ü©"
              ]
            },
            {
              "type": "paragraph",
              "text": "**Definition 21.2 (Layer Merge)**"
            },
            {
              "type": "code",
              "lines": [
                "mergeLayers(L‚ÇÅ, L‚ÇÇ) =",
                "  let shared = L‚ÇÅ ‚à© L‚ÇÇ  -- Layers with same ID",
                "  let only1 = L‚ÇÅ \\ L‚ÇÇ",
                "  let only2 = L‚ÇÇ \\ L‚ÇÅ",
                "  in only1 ‚à™ only2 ‚à™ {mergeLayer(l‚ÇÅ, l‚ÇÇ) | l‚ÇÅ ‚àà L‚ÇÅ, l‚ÇÇ ‚àà L‚ÇÇ, l‚ÇÅ.id = l‚ÇÇ.id}",
                "",
                "mergeLayer(l‚ÇÅ, l‚ÇÇ) =",
                "  require l‚ÇÅ.tier = l‚ÇÇ.tier      -- Must be same tier",
                "  require l‚ÇÅ.order = l‚ÇÇ.order    -- Must be same position",
                "  ‚ü®",
                "    id:       l‚ÇÅ.id,",
                "    name:     l‚ÇÅ.name,           -- Keep first (arbitrary but deterministic)",
                "    tier:     l‚ÇÅ.tier,",
                "    order:    l‚ÇÅ.order,",
                "    Q:        l‚ÇÅ.Q ++ \" / \" ++ l‚ÇÇ.Q,",
                "    T:        l‚ÇÅ.T ‚à™ l‚ÇÇ.T,       -- Union of element types",
                "    deps:     l‚ÇÅ.deps ‚à™ l‚ÇÇ.deps  -- Union of layer dependencies",
                "  ‚ü©"
              ]
            },
            {
              "type": "paragraph",
              "text": "**Definition 21.3 (Element Merge - LWW-Element-Set)**"
            },
            {
              "type": "code",
              "lines": [
                "mergeElements(E‚ÇÅ, E‚ÇÇ) =",
                "  let ids = {e.id | e ‚àà E‚ÇÅ} ‚à™ {e.id | e ‚àà E‚ÇÇ}",
                "  in {mergeElement(e‚ÇÅ, e‚ÇÇ) | id ‚àà ids, e‚ÇÅ = lookup(E‚ÇÅ, id), e‚ÇÇ = lookup(E‚ÇÇ, id)}",
                "",
                "mergeElement(e‚ÇÅ, e‚ÇÇ) =",
                "  case (e‚ÇÅ, e‚ÇÇ) of",
                "    (Some(e‚ÇÅ), None)      ‚Üí e‚ÇÅ",
                "    (None, Some(e‚ÇÇ))      ‚Üí e‚ÇÇ",
                "    (Some(e‚ÇÅ), Some(e‚ÇÇ))  ‚Üí",
                "      require e‚ÇÅ.layer = e‚ÇÇ.layer  -- Layer mismatch = semantic conflict",
                "      require e‚ÇÅ.type = e‚ÇÇ.type    -- Type mismatch = semantic conflict",
                "      ‚ü®",
                "        id:         e‚ÇÅ.id,",
                "        type:       e‚ÇÅ.type,",
                "        layer:      e‚ÇÅ.layer,",
                "        properties: mergeProps(e‚ÇÅ.properties, e‚ÇÇ.properties, e‚ÇÅ.metadata.version, e‚ÇÇ.metadata.version),",
                "        metadata:   mergeMetadata(e‚ÇÅ.metadata, e‚ÇÇ.metadata),",
                "        integrity:  maxIntegrity(e‚ÇÅ.integrity, e‚ÇÇ.integrity)",
                "      ‚ü©",
                "",
                "lww(val‚ÇÅ, val‚ÇÇ, v‚ÇÅ, v‚ÇÇ, actor‚ÇÅ, actor‚ÇÇ) =",
                "  if v‚ÇÅ > v‚ÇÇ then val‚ÇÅ",
                "  else if v‚ÇÇ > v‚ÇÅ then val‚ÇÇ",
                "  else if actor‚ÇÅ < actor‚ÇÇ then val‚ÇÅ  -- Tie-break by actor ID (lexicographic)",
                "  else val‚ÇÇ  -- actor‚ÇÇ ‚â§ actor‚ÇÅ"
              ]
            }
          ]
        },
        {
          "id": "sec-21-2",
          "number": "21.2",
          "title": "Composition Properties",
          "defs": [],
          "content": [
            {
              "type": "definition",
              "label": "Definition 21.4 (Compatible Specifications)",
              "text": "Two specifications S‚ÇÅ and S‚ÇÇ are compatible (Compatible(S‚ÇÅ, S‚ÇÇ)) if and only if:"
            },
            {
              "type": "code",
              "lines": [
                "Compatible(S‚ÇÅ, S‚ÇÇ) ‚â°",
                "  -- 1. No semantic conflicts in shared layers",
                "  (‚àÄl‚ÇÅ ‚àà S‚ÇÅ.layers, l‚ÇÇ ‚àà S‚ÇÇ.layers ¬∑",
                "    l‚ÇÅ.id = l‚ÇÇ.id ‚Üí",
                "      (l‚ÇÅ.tier = l‚ÇÇ.tier ‚àß l‚ÇÅ.order = l‚ÇÇ.order)) ‚àß",
                "",
                "  -- 2. No semantic conflicts in shared elements",
                "  (‚àÄe‚ÇÅ ‚àà S‚ÇÅ.elements, e‚ÇÇ ‚àà S‚ÇÇ.elements ¬∑",
                "    e‚ÇÅ.id = e‚ÇÇ.id ‚Üí",
                "      (e‚ÇÅ.layer = e‚ÇÇ.layer ‚àß e‚ÇÅ.type = e‚ÇÇ.type)) ‚àß",
                "",
                "  -- 3. No constraint conflicts (priority-based resolution)",
                "  (‚àÄc‚ÇÅ ‚àà S‚ÇÅ.constraints, c‚ÇÇ ‚àà S‚ÇÇ.constraints ¬∑",
                "    (c‚ÇÅ.scope ‚à© c‚ÇÇ.scope ‚â† ‚àÖ ‚àß c‚ÇÅ.kind = c‚ÇÇ.kind) ‚Üí",
                "      (c‚ÇÅ.priority ‚â† c‚ÇÇ.priority ‚à® c‚ÇÅ.predicate = c‚ÇÇ.predicate)) ‚àß",
                "",
                "  -- 4. No circular cross-specification dependencies",
                "  let D = S‚ÇÅ.dependencies ‚à™ S‚ÇÇ.dependencies in",
                "  ¬¨hasCycle(D) ‚àß",
                "",
                "  -- 5. Domain compatibility",
                "  (S‚ÇÅ.domain ‚à© S‚ÇÇ.domain ‚â† ‚àÖ ‚à®",
                "   S‚ÇÅ.domain = \"universal\" ‚à®",
                "   S‚ÇÇ.domain = \"universal\")"
              ]
            },
            {
              "type": "paragraph",
              "text": "**Rationale**: Compatibility ensures that merging two specifications does not introduce semantic conflicts that would violate well-formedness. Condition (1) prevents layer tier/order mismatches. Condition (2) prevents element type mismatches. Condition (3) ensures constraint conflicts can be resolved by priority ordering (per ¬ß23). Condition (4) prevents dependency cycles. Condition (5) ensures specifications have overlapping domains or are universal."
            },
            {
              "type": "theorem",
              "label": "Theorem 21.1 (Composition Commutativity)",
              "formula": "S‚ÇÅ + S‚ÇÇ = S‚ÇÇ + S‚ÇÅ (modulo id/name)"
            },
            {
              "type": "theorem",
              "label": "Theorem 21.2 (Composition Associativity)",
              "formula": "(S‚ÇÅ + S‚ÇÇ) + S‚ÇÉ = S‚ÇÅ + (S‚ÇÇ + S‚ÇÉ) (modulo id/name)"
            },
            {
              "type": "theorem",
              "label": "Theorem 21.3 (Composition Idempotency)",
              "formula": "S + S = S (modulo metadata)"
            },
            {
              "type": "theorem",
              "label": "Theorem 21.4 (Validity Preservation)",
              "formula": "Valid(S‚ÇÅ) ‚àß Valid(S‚ÇÇ) ‚àß Compatible(S‚ÇÅ, S‚ÇÇ) ‚Üí Valid(S‚ÇÅ + S‚ÇÇ)"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-22",
      "number": "22",
      "title": "Temporal Properties",
      "defs": [],
      "children": [
        {
          "id": "sec-22-1",
          "number": "22.1",
          "title": "Temporal Logic for Specifications",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "STRATUM specifications evolve over time. Temporal properties express requirements about this evolution."
            },
            {
              "type": "definition",
              "label": "Definition 22.1 (Temporal Operators - TLA+ Style)",
              "text": "Given state predicate P and action predicate A:"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "‚ñ°P",
                  "definition": "\"Always P\" - P holds in all states"
                },
                {
                  "term": "‚óáP",
                  "definition": "\"Eventually P\" - P holds in some future state"
                },
                {
                  "term": "P ‚ü∂ Q",
                  "definition": "\"P leads to Q\" - Whenever P, eventually Q"
                },
                {
                  "term": "‚ñ°[A]_v",
                  "definition": "\"A or stuttering\" - Either A occurs or v unchanged"
                },
                {
                  "term": "WF_v(A)",
                  "definition": "\"Weak fairness\" - If A enabled continuously, A eventually occurs"
                },
                {
                  "term": "SF_v(A)",
                  "definition": "\"Strong fairness\" - If A enabled infinitely often, A occurs"
                }
              ]
            },
            {
              "type": "paragraph",
              "text": "**Definition 22.2 (STRATUM Temporal Vocabulary)**"
            },
            {
              "type": "paragraph",
              "text": "State predicates:"
            },
            {
              "type": "list",
              "items": [
                "element_exists(id) - Element with id is in specification",
                "element_verified(id) - Element's binding is in verified state",
                "constraint_satisfied(c) - Constraint c is satisfied",
                "dependency_valid(d) - Dependency d has valid endpoints",
                "cascade_complete - No pending cascade propagation"
              ]
            },
            {
              "type": "paragraph",
              "text": "Action predicates:"
            },
            {
              "type": "list",
              "items": [
                "AddElement(e) - Element e is added",
                "RemoveElement(id) - Element with id is removed",
                "UpdateProperty(id, p, v) - Property p of element id set to v",
                "AddDependency(d) - Dependency d is added",
                "Verify(b) - Binding b verification initiated",
                "Cascade(e, ch) - Cascade triggered for element e, change ch"
              ]
            }
          ]
        },
        {
          "id": "sec-22-2",
          "number": "22.2",
          "title": "Standard Temporal Properties",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "SAFETY PROPERTIES (nothing bad ever happens):"
            },
            {
              "type": "rule",
              "label": "TP-1 (Constraint Preservation)",
              "formula": "‚ñ°(‚àÄc ‚àà C. constraint_satisfied(c))",
              "description": "Constraints are always satisfied"
            },
            {
              "type": "rule",
              "label": "TP-2 (Referential Integrity)",
              "formula": "‚ñ°(‚àÄd ‚àà D. dependency_valid(d))",
              "description": "Dependencies always have valid endpoints"
            },
            {
              "type": "rule",
              "label": "TP-3 (Type Stability)",
              "formula": "‚ñ°(‚àÄe ‚àà E. e.layer = e.layer' ‚àß e.type = e.type')",
              "description": "Element layer and type never change (INV-1)"
            },
            {
              "type": "rule",
              "label": "TP-4 (Integrity Monotonicity)",
              "formula": "‚ñ°(‚àÄe ‚àà E. e.integrity ‚â§ e'.integrity)",
              "description": "Integrity level can only increase"
            },
            {
              "type": "paragraph",
              "text": "LIVENESS PROPERTIES (something good eventually happens):"
            },
            {
              "type": "rule",
              "label": "TP-5 (Verification Progress)",
              "formula": "(binding.state = pending) ‚ü∂ ‚óá(binding.state ‚àà {verified, failed})",
              "description": "Pending verifications eventually complete"
            },
            {
              "type": "rule",
              "label": "TP-6 (Cascade Completion)",
              "formula": "Cascade(e, ch) ‚ü∂ ‚óácascade_complete",
              "description": "Cascades eventually terminate"
            },
            {
              "type": "rule",
              "label": "TP-7 (Sync Convergence)",
              "formula": "‚óá(‚àÄr‚ÇÅ, r‚ÇÇ. state(r‚ÇÅ) = state(r‚ÇÇ))",
              "description": "All replicas eventually converge"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-23",
      "number": "23",
      "title": "Constraint Conflict Resolution",
      "defs": [],
      "children": [
        {
          "id": "sec-23-1",
          "number": "23.1",
          "title": "Priority-Based Override Semantics",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "When constraints conflict, resolution is determined by priority."
            },
            {
              "type": "definition",
              "label": "Definition 23.1 (Constraint Priority)",
              "text": "Priority sources (highest to lowest):"
            },
            {
              "type": "definition-list",
              "items": [
                {
                  "term": "1. REGULATORY (priority 1000+)",
                  "definition": "Safety standard requirements (DO-178C, ISO 26262), Legal/compliance mandates, Regulatory body directives"
                },
                {
                  "term": "2. SAFETY (priority 500-999)",
                  "definition": "ASIL-D/DAL-A requirements, Hazard mitigations, Security requirements"
                },
                {
                  "term": "3. ARCHITECTURAL (priority 100-499)",
                  "definition": "System-level constraints, Interface contracts, Performance requirements"
                },
                {
                  "term": "4. DESIGN (priority 10-99)",
                  "definition": "Component constraints, Module boundaries, Coding standards"
                },
                {
                  "term": "5. PREFERENCE (priority 1-9)",
                  "definition": "Style guidelines, Naming conventions, Optional recommendations"
                }
              ]
            },
            {
              "type": "definition",
              "label": "Definition 23.2 (Conflict Detection)",
              "text": "Two constraints c‚ÇÅ and c‚ÇÇ conflict iff:\n  ‚àÉ œÉ. sat(c‚ÇÅ, œÉ) ‚àß sat(c‚ÇÇ, œÉ) ‚àß ¬¨sat(c‚ÇÅ ‚àß c‚ÇÇ, œÉ)"
            },
            {
              "type": "paragraph",
              "text": "Conflict types:"
            },
            {
              "type": "list",
              "items": [
                "DIRECT: c‚ÇÅ ‚àß c‚ÇÇ is unsatisfiable",
                "INDIRECT: c‚ÇÅ ‚àß c‚ÇÇ ‚àß D is unsatisfiable (D = derived constraints)",
                "RESOURCE: c‚ÇÅ and c‚ÇÇ compete for limited resource",
                "TEMPORAL: c‚ÇÅ and c‚ÇÇ impose conflicting timing"
              ]
            }
          ]
        },
        {
          "id": "sec-23-2",
          "number": "23.2",
          "title": "Resolution Algorithm",
          "defs": [],
          "content": [
            {
              "type": "code",
              "lines": [
                "function resolveConflicts(C: Set<Constraint>) ‚Üí ResolvedSet:",
                "  conflicts := detectConflicts(C)",
                "  resolved := {}",
                "  overridden := {}",
                "",
                "  for (c‚ÇÅ, c‚ÇÇ, type) in conflicts:",
                "    if c‚ÇÅ.priority > c‚ÇÇ.priority:",
                "      overridden.add(c‚ÇÇ)",
                "      resolved.add({",
                "        winner: c‚ÇÅ,",
                "        loser: c‚ÇÇ,",
                "        reason: 'priority',",
                "        type: type",
                "      })",
                "    else if c‚ÇÇ.priority > c‚ÇÅ.priority:",
                "      overridden.add(c‚ÇÅ)",
                "      resolved.add({",
                "        winner: c‚ÇÇ,",
                "        loser: c‚ÇÅ,",
                "        reason: 'priority',",
                "        type: type",
                "      })",
                "    else:",
                "      // Equal priority - flag for manual resolution",
                "      resolved.add({",
                "        winner: null,",
                "        loser: null,",
                "        reason: 'manual_required',",
                "        type: type,",
                "        constraints: [c‚ÇÅ, c‚ÇÇ]",
                "      })",
                "",
                "  return {",
                "    active: C \\ overridden,",
                "    overridden: overridden,",
                "    resolutions: resolved,",
                "    manualRequired: resolved.filter(r => r.reason = 'manual_required')",
                "  }"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "sec-24",
      "number": "24",
      "title": "Garbage Collection Proofs",
      "defs": [],
      "children": [
        {
          "id": "sec-24-1",
          "number": "24.1",
          "title": "GC Safety Requirements",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Garbage collection in CRDTs must preserve convergence properties."
            },
            {
              "type": "definition",
              "label": "Definition 24.1 (GC Safety)",
              "text": "A garbage collection operation gc : State ‚Üí State is SAFE iff:"
            },
            {
              "type": "rule",
              "label": "GC-1 (Convergence Preservation)",
              "formula": "‚àÄ s‚ÇÅ, s‚ÇÇ. s‚ÇÅ ‚äî s‚ÇÇ = s‚ÇÉ ‚üπ gc(s‚ÇÅ) ‚äî gc(s‚ÇÇ) = gc(s‚ÇÉ)",
              "description": "GC commutes with merge"
            },
            {
              "type": "rule",
              "label": "GC-2 (Causal Stability)",
              "formula": "gc removes tombstone t only if: ‚àÄ replica r. r has observed t",
              "description": "No replica can generate conflicting operation"
            },
            {
              "type": "rule",
              "label": "GC-3 (No Information Loss)",
              "formula": "‚àÄ op. applicable(op, s) ‚üπ applicable(op, gc(s))",
              "description": "GC doesn't break future operations"
            },
            {
              "type": "definition",
              "label": "Definition 24.2 (Tombstone Stability)",
              "text": "A tombstone t is STABLE at replica r iff:\n  ‚àÄ replica r'. r'.clock ‚â• clock_at_creation(t)\n\nInformally: All replicas have \"caught up\" past the tombstone creation."
            },
            {
              "type": "paragraph",
              "text": "Stability detection methods:"
            },
            {
              "type": "list",
              "items": [
                "1. VECTOR CLOCK COMPARISON: t stable when min(all_clocks) ‚â• t.clock",
                "2. ACKNOWLEDGMENT: Each replica explicitly acks receiving t",
                "3. CHECKPOINT: Periodic global synchronization point",
                "4. TIME-BASED: t stable after duration D (requires clock sync)"
              ]
            }
          ]
        },
        {
          "id": "sec-24-2",
          "number": "24.2",
          "title": "GC Correctness Proofs",
          "defs": [],
          "content": [
            {
              "type": "theorem",
              "label": "Theorem 24.1 (Checkpoint GC Safety)",
              "formula": "Given:\n  - All replicas reach checkpoint C\n  - Tombstone t was created before C\n  - gc removes t after checkpoint\nThen: gc satisfies GC-1, GC-2, GC-3"
            },
            {
              "type": "paragraph",
              "text": "Proof:"
            },
            {
              "type": "list",
              "items": [
                "GC-1: At checkpoint, all replicas have same state. gc applied uniformly to identical states produces identical results. ‚äî on identical states is idempotent, so gc(s) ‚äî gc(s) = gc(s). ‚úì",
                "GC-2: Checkpoint C guarantees all replicas observed t. No replica can generate add operation for element with tombstone t (causally after). Therefore, t is stable. ‚úì",
                "GC-3: Operations concurrent with t would have been merged before checkpoint. Post-checkpoint operations cannot conflict with t (causal order). ‚úì"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "sec-26",
      "number": "26",
      "title": "Certification Objective Coverage Matrix",
      "defs": [],
      "children": [
        {
          "id": "sec-26-1",
          "number": "26.1",
          "title": "DO-178C Objective Coverage [v2.4]",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Status legend:\n  ‚úì ADDRESSED - Specification provides mechanism to satisfy\n  ‚óê TOOL - Depends on implementing tool\n  ‚óã PROCESS - Organizational process required\n  ‚úó GAP - Not addressed (documented below)"
            },
            {
              "type": "admonition",
              "level": "correction",
              "text": "v2.4 CORRECTION: DO-178C specifies 71 objectives at DAL-A (was incorrectly 70 in v2.3)"
            },
            {
              "type": "table",
              "label": "Summary by Table",
              "columns": ["Table", "Total", "‚úì Addressed", "‚óê Tool", "‚óã Process", "‚úó Gap"],
              "rows": [
                ["A-1", "7", "2", "0", "5", "0"],
                ["A-2", "7", "5", "2", "0", "0"],
                ["A-3", "7", "5", "1", "1", "0"],
                ["A-4", "13", "9", "2", "2", "0"],
                ["A-5", "9", "5", "3", "1", "0"],
                ["A-6", "5", "1", "4", "0", "0"],
                ["A-7", "5", "2", "3", "0", "0"],
                ["A-8", "9", "6", "2", "1", "0"],
                ["A-9", "4", "3", "0", "1", "0"],
                ["A-10", "5", "3", "0", "2", "0"],
                ["TOTAL", "71", "41", "17", "13", "0"]
              ]
            },
            {
              "type": "paragraph",
              "text": "INTERPRETATION:\n\n‚Ä¢ 41 objectives: STRATUM specification directly addresses\n‚Ä¢ 17 objectives: Require implementing tool (e.g., compiler, test harness)\n‚Ä¢ 13 objectives: Require organizational process (outside tool scope)\n‚Ä¢ 0 objectives: Gaps requiring specification changes\n\nFOR CERTIFICATION:\nAll 71 objectives must be satisfied. STRATUM addresses 41 directly.\nImplementing organization must:\n  1. Select/develop tools satisfying 17 tool-dependent objectives\n  2. Define processes satisfying 13 process objectives\n  3. Document rationale in Software Accomplishment Summary\n\nThere is no \"percentage compliance\" - either all objectives are satisfied with documented evidence, or certification cannot be achieved."
            }
          ]
        },
        {
          "id": "sec-26-2",
          "number": "26.2",
          "title": "ISO 26262 Objective Coverage",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Part 6: Product development at the software level"
            },
            {
              "type": "table",
              "columns": ["Clause", "Status"],
              "rows": [
                ["6.5: Initiation of product development at software level", "‚óã PROCESS"],
                ["6.6: Specification of software safety requirements", "‚úì (¬ß2-4)"],
                ["6.7: Software architectural design", "‚úì (¬ß3)"],
                ["6.8: Software unit design and implementation", "‚óê TOOL"],
                ["6.9: Software unit verification", "‚úì (¬ß4,14)"],
                ["6.10: Software integration and verification", "‚óê TOOL"],
                ["6.11: Verification of software safety requirements", "‚úì (¬ß4,14)"],
                ["6.12: Software configuration management", "‚úì (¬ß14)"]
              ]
            },
            {
              "type": "paragraph",
              "text": "Part 9: Automotive Safety Integrity Level (ASIL)-oriented and safety-oriented analyses [v2.4 ADDRESSED]"
            },
            {
              "type": "table",
              "columns": ["Clause", "Status"],
              "rows": [
                ["9.5: Analyses of dependent failures", "‚úì (¬ß27.4)"],
                ["9.7: Safety analyses (STPA)", "‚úì (¬ß27.2)"],
                ["9.8: Safety analyses (FMEA/FTA)", "‚úì (¬ß27.3)"]
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "sec-27",
      "number": "27",
      "title": "STPA/FMEA Integration Framework",
      "defs": [],
      "children": [
        {
          "id": "sec-27-1",
          "number": "27.1",
          "title": "ISO 26262 Part 9 Requirements",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "v2.3 identified gaps in ISO 26262 Part 9 (sections 9.7-9.8). v2.4 closes these gaps with a formal STPA/FMEA integration framework."
            },
            {
              "type": "table",
              "columns": ["ISO 26262-9 Requirement", "v2.3 Status", "v2.4 Status"],
              "rows": [
                ["9.7: Dependent failure analysis", "‚úó GAP", "‚úì ADDRESSED (¬ß27.4)"],
                ["9.8: Safety analyses (FMEA/FTA)", "‚úó GAP", "‚úì ADDRESSED (¬ß27.2-27.3)"]
              ]
            },
            {
              "type": "paragraph",
              "text": "Reference standards:\n  ‚Ä¢ SAE J3187 (2022): STPA-Based Safety Analysis of Automotive Systems\n  ‚Ä¢ SAE J3307 (2025): STPA Recommended Practice\n  ‚Ä¢ Leveson (2011): Engineering a Safer World"
            }
          ]
        },
        {
          "id": "sec-27-2",
          "number": "27.2",
          "title": "STPA Integration",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "STPA (System-Theoretic Process Analysis) is a top-down hazard analysis method. STRATUM integrates STPA via explicit modeling of control structures."
            },
            {
              "type": "paragraph",
              "text": "**Definition 27.1 (STPA Control Structure)**"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "interface STPAControlAction {",
                "  id: string;",
                "  name: string;",
                "  controller: ElementID;        // STRATUM element providing control",
                "  controlledProcess: ElementID; // STRATUM element being controlled",
                "  actuator?: ElementID;         // Optional actuator element",
                "  sensor?: ElementID;           // Optional sensor element",
                "  feedbackLoop: boolean;",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "**Definition 27.2 (Unsafe Control Action - UCA)**"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "// STPA Handbook (Leveson & Thomas 2018) defines four provably complete UCA types.",
                "// WRONG_DIRECTION is a subcategory of PROVIDED_WRONG for parametric control actions.",
                "type UCAType =",
                "  | 'NOT_PROVIDED'      // Type 1: Required action not provided",
                "  | 'PROVIDED_WRONG'    // Type 2: Action provided incorrectly (includes WRONG_DIRECTION)",
                "  | 'WRONG_TIMING'      // Type 3: Too early, too late, or out of sequence",
                "  | 'STOPPED_TOO_SOON'  // Type 4: Stopped too soon or applied too long",
                "  | 'WRONG_DIRECTION';  // Parametric subcategory: wrong polarity/direction (subset of Type 2)",
                "",
                "interface UnsafeControlAction {",
                "  id: string;",
                "  controlActionId: string;",
                "  ucaType: UCAType;",
                "  context: string;          // When this UCA is hazardous",
                "  hazard: HazardID;         // Link to system hazard",
                "  safetyConstraint: string; // Derived safety constraint",
                "  formalProperty?: string;  // STRATUM constraint derivation",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "**Definition 27.3 (Causal Scenario)**"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "type ScenarioType =",
                "  | 'CONTROLLER_FAILURE'     // Controller logic error",
                "  | 'ACTUATOR_FAILURE'       // Actuator malfunction",
                "  | 'SENSOR_FAILURE'         // Sensor provides wrong feedback",
                "  | 'COMMUNICATION_FAILURE'  // Message corruption or delay",
                "  | 'PROCESS_MODEL_FAILURE'  // Incorrect mental model",
                "  | 'EXTERNAL_DISTURBANCE';  // Environmental factor"
              ]
            },
            {
              "type": "paragraph",
              "text": "Algorithm 26.1 (STPA-to-STRATUM Constraint Derivation):\n\nFor each UCA identified:\n\n1. Extract safety constraint from UCA negation:\n   UCA: \"Brake command not provided when vehicle speed > 0 and obstacle ahead\"\n   SC:  \"Brake command MUST be provided when speed > 0 AND obstacle detected\"\n\n2. Map to STRATUM constraint:\n   {\n     type: 'SAFETY',\n     priority: 500,  // SAFETY level per ¬ß23\n     predicate: 'IF speed > 0 AND obstacle THEN brakeCommand = ACTIVE',\n     source: { type: 'STPA', ucaId: 'UCA-001', hazardId: 'H-003' }\n   }\n\n3. Verify formal property:\n   ‚ñ°(speed > 0 ‚àß obstacle ‚Üí ‚óá‚â§100ms brakeCommand = ACTIVE)\n\n4. Add to RTM with bidirectional traceability:\n   Hazard ‚Üí UCA ‚Üí Safety Constraint ‚Üí STRATUM Constraint ‚Üí Formal Property"
            }
          ]
        },
        {
          "id": "sec-27-3",
          "number": "27.3",
          "title": "FMEA/FTA Integration",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "FMEA (inductive, bottom-up) and FTA (deductive, top-down) complement STPA."
            },
            {
              "type": "paragraph",
              "text": "**Definition 27.4 (FMEA Entry)**"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "interface FMEAEntry {",
                "  elementId: ElementID;           // STRATUM element being analyzed",
                "  failureMode: string;            // How the element can fail",
                "  localEffect: string;            // Effect on immediate subsystem",
                "  systemEffect: string;           // Effect on overall system",
                "  severity: 1 | 2 | 3 | 4 | 5;    // 5 = catastrophic",
                "  occurrence: 1 | 2 | 3 | 4 | 5;  // 5 = very likely",
                "  detection: 1 | 2 | 3 | 4 | 5;   // 5 = undetectable",
                "  rpn: number;                    // Risk Priority Number = S √ó O √ó D",
                "  mitigation: string;",
                "  derivedConstraint?: ConstraintID;  // STRATUM constraint if RPN > threshold",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "**Recommended RPN Thresholds by ASIL** (STRATUM recommendations, not ISO 26262 requirements):\n\nNote: ISO 26262 uses HARA (Severity √ó Exposure √ó Controllability) matrices, not RPN multiplication. These thresholds represent commonly used industry practice (typical organizational thresholds range 100-150). AIAG-VDA FMEA (2019) introduced Action Priority as an alternative.\n\n  ASIL-D: RPN > 8 requires mitigation\n  ASIL-C: RPN > 16 requires mitigation\n  ASIL-B: RPN > 32 requires mitigation\n  ASIL-A: RPN > 64 requires mitigation"
            },
            {
              "type": "paragraph",
              "text": "**Definition 27.5 (FTA Gate)**"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "type FTAGate = 'AND' | 'OR' | 'XOR' | 'PRIORITY_AND' | 'INHIBIT';",
                "",
                "interface FTANode {",
                "  id: string;",
                "  type: 'TOP_EVENT' | 'INTERMEDIATE' | 'BASIC_EVENT' | 'UNDEVELOPED';",
                "  description: string;",
                "  gate?: FTAGate;",
                "  children?: FTANode[];",
                "  elementId?: ElementID;      // Link to STRATUM element for basic events",
                "  failureRate?: number;       // Œª (failures per hour) for quantitative FTA",
                "  cutSets?: string[][];       // Minimal cut sets (computed)",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "FTA-to-STRATUM mapping:\n  ‚Ä¢ Basic events ‚Üí Element failure modes\n  ‚Ä¢ Intermediate events ‚Üí Subsystem failures\n  ‚Ä¢ Top event ‚Üí System hazard\n  ‚Ä¢ Minimal cut sets ‚Üí Dependent failure combinations"
            }
          ]
        },
        {
          "id": "sec-27-4",
          "number": "27.4",
          "title": "Dependent Failure Analysis",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "ISO 26262-9.7 requires analysis of dependent failures including:\n  ‚Ä¢ Common Cause Failures (CCF)\n  ‚Ä¢ Cascading Failures\n  ‚Ä¢ Common Mode Failures"
            },
            {
              "type": "paragraph",
              "text": "**Definition 27.6 (Dependent Failure)**"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "interface DependentFailure {",
                "  id: string;",
                "  type: 'CCF' | 'CASCADE' | 'COMMON_MODE';",
                "  affectedElements: ElementID[];",
                "  commonCause?: string;           // Root cause for CCF",
                "  propagationPath?: ElementID[];  // Path for cascading failures",
                "  coupling: 'HARDWARE' | 'SOFTWARE' | 'ENVIRONMENTAL' | 'HUMAN';",
                "  mitigations: string[];",
                "  residualRisk: 'ACCEPTABLE' | 'TOLERABLE' | 'UNACCEPTABLE';",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "STRATUM integration:\n\n1. CCF analysis uses layer boundaries:\n   Elements in same layer share implementation ‚Üí potential CCF\n   Elements in different tiers have architectural separation\n\n2. Cascade analysis uses dependency graph:\n   impactedElements(change) ‚Üí identifies cascade paths\n   Attenuation function (¬ß18) limits cascade propagation\n\n3. Common mode uses type hierarchy:\n   Elements of same type may share failure modes\n   Variant types (per ¬ß2.2) indicate potential common mode"
            }
          ]
        },
        {
          "id": "sec-27-5",
          "number": "27.5",
          "title": "Quantitative Safety Metrics",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "ISO 26262 requires quantitative metrics for hardware; software uses them as supporting evidence."
            },
            {
              "type": "table",
              "columns": ["Metric", "Formula", "Target (ASIL-D)"],
              "rows": [
                ["SPFM", "1 - Œ£(ŒªSPF)/Œ£(Œª)", "‚â• 99%"],
                ["LFM", "1 - Œ£(ŒªLF)/Œ£(Œª)", "‚â• 90%"],
                ["PMHF", "Œ£(Œªresidual)", "< 10 FIT"]
              ]
            },
            {
              "type": "paragraph",
              "text": "Where:\n  SPFM = Single Point Fault Metric\n  LFM = Latent Fault Metric\n  PMHF = Probabilistic Metric for Hardware Failures\n  FIT = Failures in Time (per 10‚Åπ hours)\n\nSTRATUM supports these by:\n  ‚Ä¢ Tracking element failure rates in metadata\n  ‚Ä¢ Computing SPFM/LFM from safety mechanism coverage\n  ‚Ä¢ Generating PMHF estimates from FTA cut set analysis"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-28",
      "number": "28",
      "title": "Formal Attenuation Properties",
      "defs": [],
      "children": [
        {
          "id": "sec-28-1",
          "number": "28.1",
          "title": "Attenuation Function Specification",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "The attenuation function controls cascade propagation across layer boundaries. v2.4 adds formal properties required for safety analysis."
            },
            {
              "type": "definition",
              "label": "Definition 28.1 (Attenuation Function - Formal)",
              "text": "attenuate : Impact √ó Layer √ó Layer ‚Üí Impact\n\nSignature:\n  attenuate(impact: Impact, source: Layer, target: Layer): Impact\n\nWhere Impact = { severity: ‚Ñï, scope: Set<ElementID>, energy: ‚Ñï }"
            },
            {
              "type": "definition",
              "label": "Definition 28.2 (Monotonicity - Required)",
              "text": "‚àÄ impact‚ÇÅ, impact‚ÇÇ, source, target:\n  impact‚ÇÅ.energy ‚â§ impact‚ÇÇ.energy\n  ‚áí attenuate(impact‚ÇÅ, source, target).energy\n     ‚â§ attenuate(impact‚ÇÇ, source, target).energy\n\n(Larger inputs produce at-most-larger outputs; no amplification inversions)"
            },
            {
              "type": "definition",
              "label": "Definition 28.3 (Strict Reduction - Required)",
              "text": "‚àÄ impact, source, target where source ‚â† target:\n  attenuate(impact, source, target).energy < impact.energy\n\n(Crossing a layer boundary ALWAYS reduces energy; required for termination)"
            },
            {
              "type": "definition",
              "label": "Definition 28.4 (BIBO Stability - Required)",
              "text": "BIBO = Bounded Input, Bounded Output\n\n‚àÄ impact, source, target:\n  impact.energy ‚â§ MAX_ENERGY\n  ‚áí attenuate(impact, source, target).energy ‚â§ MAX_ENERGY\n\n(Bounded inputs produce bounded outputs; required for safety analysis)"
            },
            {
              "type": "definition",
              "label": "Definition 28.5 (Default Tier Attenuation Factor) [v2.5]",
              "text": "The DEFAULT attenuation function for K0 conformance is exponential decay:\n\nŒ≥(tier_diff) = 2^(-tier_diff)  for tier_diff > 0\nŒ≥(0) = 1                        for same-tier (no attenuation)\n\nExample:\n  Tier 3 ‚Üí Tier 2: Œ≥ = 0.5 (halved)\n  Tier 3 ‚Üí Tier 1: Œ≥ = 0.25 (quartered)\n  Tier 3 ‚Üí Tier 0: Œ≥ = 0.125 (eighth)\n\n**Alternative Attenuation Functions**: Domain profiles MAY define custom attenuation functions iff they satisfy Definitions 28.2-28.4 (Monotonicity, Strict Reduction, BIBO Stability). K0 implementations MUST support the default exponential decay. K2+ implementations MAY support custom functions."
            },
            {
              "type": "definition",
              "label": "Definition 28.6 (Attenuation Function Type) [v2.5]",
              "text": "ATTENUATION_FUNCTION = { f : ‚Ñï ‚Üí [0,1] | satisfies(f, {Monotonic, StrictReduction, BIBOStable}) }\n\nwhere:\n  Monotonic(f) ‚â° ‚àÄ n‚ÇÅ, n‚ÇÇ. n‚ÇÅ ‚â§ n‚ÇÇ ‚áí f(n‚ÇÅ) ‚â• f(n‚ÇÇ)\n  StrictReduction(f) ‚â° ‚àÄ n > 0. f(n) < 1\n  BIBOStable(f) ‚â° ‚àÄ n. f(n) ‚àà [0, 1]\n\n**Example Alternative Functions**:\n  ‚Ä¢ Linear: Œ≥(n) = max(0, 1 - 0.25√ón)  [satisfies all properties for n ‚â§ 4]\n  ‚Ä¢ Logarithmic: Œ≥(n) = 1 / (1 + log‚ÇÇ(1+n))  [satisfies all properties]\n  ‚Ä¢ Step: Œ≥(0)=1, Œ≥(1)=0.5, Œ≥(n‚â•2)=0.1  [satisfies all properties]"
            },
            {
              "type": "admonition",
              "level": "important",
              "text": "**Composition of Attenuation Functions**: When multiple cascade rules apply to the same dependency path, attenuation factors MULTIPLY: final_impact = initial_impact √ó Œ≥‚ÇÅ √ó Œ≥‚ÇÇ √ó ... √ó Œ≥‚Çô. Since each Œ≥·µ¢ ‚àà (0,1], the product Œ≥‚ÇÅ√óŒ≥‚ÇÇ√ó...√óŒ≥‚Çô ‚àà (0,1], preserving Monotonicity and Strict Reduction. This follows from the closure property of (0,1] under multiplication."
            },
            {
              "type": "theorem",
              "label": "Theorem 28.1 (Cascade Bound)",
              "formula": "Given:\n  ‚Ä¢ Initial impact energy E‚ÇÄ\n  ‚Ä¢ n tiers in specification\n  ‚Ä¢ Minimum attenuation factor Œ≥_min = 2^(-1) = 0.5\n  ‚Ä¢ Energy threshold Œµ = 1 (minimum detectable impact)\n\nThen:\n  Total cascade energy ‚â§ E‚ÇÄ √ó Œ£·µ¢‚Çå‚ÇÄ‚Åø‚Åª¬π Œ≥_min^i = E‚ÇÄ √ó (1 - Œ≥_min^n)/(1 - Œ≥_min)\n\nFor n = 4 tiers: Total ‚â§ E‚ÇÄ √ó (1 - 0.5‚Å¥)/(1 - 0.5) = E‚ÇÄ √ó 1.875\n\nCorollary (Path Termination): Any single cross-tier propagation path terminates in at most ‚åàlog‚ÇÇ(E‚ÇÄ/Œµ)‚åâ steps.\nProof: After k steps, energy ‚â§ E‚ÇÄ √ó (0.5)^k. Set E‚ÇÄ √ó (0.5)^k ‚â§ Œµ and solve: k ‚â• log‚ÇÇ(E‚ÇÄ/Œµ).\n\nNote: Graph-wide cascade may have O(|E| + |D|) propagations, but each individual path is logarithmic."
            },
            {
              "type": "diagram",
              "format": "ascii",
              "content": "Impact Energy\n    ‚îÇ\n100%‚îÇ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n    ‚îÇ       ‚îÉ\n 50%‚îÇ‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚î∫‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n    ‚îÇ               ‚îÉ\n 25%‚îÇ‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚î∫‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n    ‚îÇ                       ‚îÉ\n12.5‚îÇ‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚î∫‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n    ‚îÇ                               ‚îÉ\n 6.3‚îÇ‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚ï∂‚î∫‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n    ‚îÇ                                       ‚îÉ\n 0% ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î∫‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚Üí\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n          Tier 0  Tier 1  Tier 2  Tier 3  Tier 4\n        (motiv) (logical)(realiz)(ground) (impl)\n    \n    Impact at tier n: Œ≥‚Åø = (0.5)‚Åø\n    \n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ THEOREM 28.1: Total cascade energy   ‚îÇ\n    ‚îÇ ‚â§ 2√óE‚ÇÄ (geometric series converges)  ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n    \n    ATTENUATION GUARANTEES:\n    ‚Ä¢ Monotonicity: Œ≥‚Åø‚Å∫¬π < Œ≥‚Åø  (strictly decreasing)\n    ‚Ä¢ Strict Reduction: Each tier crossing reduces energy\n    ‚Ä¢ BIBO Stability: Bounded input ‚Üí bounded output\n    ‚Ä¢ Termination: Series converges in finite steps",
              "caption": "Figure 28.1: Attenuation decay curve showing exponential energy reduction Œ≥(n) = 2^(-n) across tier boundaries. The geometric series Œ£Œ≥‚Åø converges to 2√óE‚ÇÄ, guaranteeing cascade termination.",
              "alt": "Graph showing impact energy decay from 100% to near 0% across 5 tiers with exponential attenuation. Each tier crossing halves the impact energy, demonstrating the Œ≥ = 2^(-tier_diff) attenuation function."
            }
          ]
        },
        {
          "id": "sec-28-2",
          "number": "28.2",
          "title": "Attenuation Verification",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Runtime verification implementation:"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "export function verifyAttenuationProperties(): boolean {",
                "  const MAX_ENERGY = 1000;",
                "",
                "  // Test monotonicity",
                "  const impact1 = { severity: 5, scope: new Set(['a']), energy: 50 };",
                "  const impact2 = { severity: 5, scope: new Set(['a']), energy: 100 };",
                "  const result1 = attenuate(impact1, 3, 1);",
                "  const result2 = attenuate(impact2, 3, 1);",
                "  const monotonic = result1.energy <= result2.energy;",
                "",
                "  // Test strict reduction (cross-tier)",
                "  const impactOrig = { severity: 5, scope: new Set(['a']), energy: 100 };",
                "  const resultCross = attenuate(impactOrig, 3, 2);",
                "  const strictReduction = resultCross.energy < impactOrig.energy;",
                "",
                "  // Test BIBO stability",
                "  const maxImpact = { severity: 10, scope: new Set(['a']), energy: MAX_ENERGY };",
                "  const resultMax = attenuate(maxImpact, 3, 0);",
                "  const biboStable = resultMax.energy <= MAX_ENERGY;",
                "",
                "  return monotonic && strictReduction && biboStable;",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "For certification, provide:\n  ‚Ä¢ Formal proof of monotonicity (Coq/Lean)\n  ‚Ä¢ Formal proof of strict reduction\n  ‚Ä¢ Formal proof of BIBO stability\n  ‚Ä¢ Property-based tests (QuickCheck) for implementation"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-29",
      "number": "29",
      "title": "Cross-Standard Traceability Matrix",
      "defs": [],
      "children": [
        {
          "id": "sec-29-1",
          "number": "29.1",
          "title": "DO-178C ‚Üî ISO 26262 Equivalence",
          "defs": [],
          "content": [
            {
              "type": "table",
              "columns": ["DO-178C (Avionics)", "ISO 26262 (Automotive)", "STRATUM Section"],
              "rows": [
                ["DAL-A (Catastrophic)", "ASIL-D (Life-threatening)", "Tier 0, Mechanized proof"],
                ["DAL-B (Hazardous)", "ASIL-C (Severe injury)", "Tier 1, TLA+/Type-system"],
                ["DAL-C (Major)", "ASIL-B (Injury)", "Tier 2, PBT+BMC"],
                ["DAL-D (Minor)", "ASIL-A (Light injury)", "Tier 3, Unit tests"],
                ["DAL-E (No effect)", "QM (No safety impact)", "Tier 3+, Minimal"]
              ]
            },
            {
              "type": "paragraph",
              "text": "**Important Caveat**: This DAL ‚Üî ASIL mapping represents commonly used industry practice for cross-domain analysis but is **NOT formally standardized**. ISO 26262 explicitly does not provide normative mappings to aviation DALs. Critical differences include:\n\n- **Scope**: DAL-A encompasses hazards of fully loaded aircraft (potentially hundreds of fatalities), while ASIL-D at most covers passenger van hazards (~8 occupants)\n- **Derivation**: DAL uses probabilistic hazard analysis (14 CFR 25.1309), ASIL uses HARA risk assessment (Severity √ó Exposure √ó Controllability)\n- **Standards**: DO-178C focuses on software development rigor, ISO 26262 addresses full system lifecycle\n\nThis mapping should be interpreted as \"commonly used for conceptual alignment\" rather than implying normative equivalence."
            }
          ]
        },
        {
          "id": "sec-29-2",
          "number": "29.2",
          "title": "Process Mapping",
          "defs": [],
          "content": [
            {
              "type": "table",
              "columns": ["Activity", "DO-178C Reference", "ISO 26262 Reference"],
              "rows": [
                ["Requirements tracing", "Table A-3, Obj 6", "Part 6, 6.6.2"],
                ["Architecture design", "Table A-4, Obj 8-9", "Part 6, 6.7"],
                ["Code verification", "Table A-5", "Part 6, 6.8-6.9"],
                ["Tool qualification", "DO-330", "Part 8, Clause 11"],
                ["Configuration mgmt", "Table A-8", "Part 8, Clause 8"],
                ["Safety analysis", "(via ARP4761)", "Part 9, Clause 8-9"],
                ["Hazard analysis", "(via ARP4761)", "Part 3 (HARA)"]
              ]
            }
          ]
        },
        {
          "id": "sec-29-3",
          "number": "29.3",
          "title": "Tool Qualification Mapping",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "**DO-330 TQL ‚Üî ISO 26262 TCL Conceptual Mapping** (not formally standardized):\n\nImportant: No official cross-standard mapping exists. DO-330 defines 5 TQL levels (TQL-1 most rigorous), ISO 26262 Part 8 defines 3 TCL levels (TCL3 highest confidence). Both frameworks assess tool risk through impact and error detection capability, but differ structurally. DO-330 is noted as applicable cross-domain, but the mapping below represents conceptual parallels, not normative correspondence."
            },
            {
              "type": "paragraph",
              "text": "Suggested TQL ‚Üî TCL alignment:"
            },
            {
              "type": "table",
              "columns": ["DO-330 (TQL)", "ISO 26262 (TCL)", "Qualification Effort"],
              "rows": [
                ["TQL-1", "TCL3 + TI1", "Full development lifecycle evidence"],
                ["TQL-2", "TCL3 + TI2", "Development + extensive validation"],
                ["TQL-3", "TCL2", "Use history + validation"],
                ["TQL-4", "TCL2", "Use history or validation"],
                ["TQL-5", "TCL1", "Minimal or none"]
              ]
            },
            {
              "type": "paragraph",
              "text": "STRATUM tool classification (from ¬ß18):"
            },
            {
              "type": "table",
              "columns": ["STRATUM Component", "DO-330 TQL", "ISO 26262 TCL", "Criteria"],
              "rows": [
                ["Specification Store", "TQL-1", "TCL3 + TI1", "Output insertion"],
                ["RTM Generator", "TQL-4", "TCL2", "Verification"],
                ["Constraint Validator", "TQL-4", "TCL2", "Verification"],
                ["Impact Analyzer", "TQL-4", "TCL2", "Verification"],
                ["Checklist Generator", "TQL-5", "TCL1", "Output not trusted"],
                ["Visualization", "TQL-5", "TCL1", "No safety impact"]
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "sec-30",
      "number": "30",
      "title": "Tier Boundary Formal Semantics",
      "defs": [],
      "children": [
        {
          "id": "sec-30-1",
          "number": "30.1",
          "title": "LSL-Style Tier Separation",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Following Larch Shared Language (LSL) patterns for specification layers."
            },
            {
              "type": "definition",
              "label": "Definition 30.1 (Sort Hierarchy)",
              "text": "Each tier defines a sort (type universe) with explicit mappings:"
            },
            {
              "type": "code",
              "lines": [
                "Tier[0] : Sort_Critical",
                "  ‚Üí Types: CriticalElement, SafetyConstraint, HazardMitigation",
                "  ‚Üí Properties: ASIL-D/DAL-A verified, mechanized proofs",
                "",
                "Tier[1] : Sort_High",
                "  ‚Üí Types: HighIntegrityElement, VerifiedConstraint",
                "  ‚Üí Properties: ASIL-C/DAL-B verified, model-checked",
                "",
                "Tier[2] : Sort_Medium",
                "  ‚Üí Types: MediumIntegrityElement, TestedConstraint",
                "  ‚Üí Properties: ASIL-B/DAL-C verified, property-tested",
                "",
                "Tier[3] : Sort_Low",
                "  ‚Üí Types: LowIntegrityElement, ReviewedConstraint",
                "  ‚Üí Properties: ASIL-A/DAL-D verified, code-reviewed"
              ]
            },
            {
              "type": "definition",
              "label": "Definition 30.2 (Sort Inclusion)",
              "text": "Lower tiers may reference higher tiers (dependencies flow downward):\n\n  Sort_Low ‚äá Sort_Medium ‚äá Sort_High ‚äá Sort_Critical\n\nInterpretation: Low-tier code may call high-tier functions, but not vice versa. This enforces the \"no upward dependencies\" invariant architecturally."
            },
            {
              "type": "paragraph",
              "text": "**Definition 30.3 (Cross-Tier Interface)**"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "interface TierBoundary<S_source, S_target> {",
                "  // Source tier (lower integrity)",
                "  sourceTier: Tier;",
                "  sourceSort: S_source;",
                "",
                "  // Target tier (higher integrity)",
                "  targetTier: Tier;",
                "  targetSort: S_target;",
                "",
                "  // Crossing requires explicit validation",
                "  crossing: (value: S_source) => Validated<S_target> | Error;",
                "",
                "  // Attenuation applied at crossing",
                "  attenuation: AttenuationFactor;",
                "}"
              ]
            },
            {
              "type": "paragraph",
              "text": "Invariant: Cross-tier dependencies must go through TierBoundary interface. This is enforced at the type level in implementations."
            }
          ]
        },
        {
          "id": "sec-30-2",
          "number": "30.2",
          "title": "Type-to-Sort Mapping",
          "defs": [],
          "content": [
            {
              "type": "paragraph",
              "text": "Each STRATUM element type maps to a sort based on its containing layer's tier:"
            },
            {
              "type": "table",
              "columns": ["Element Type", "Layer Tier", "Mapped Sort", "Verification Required"],
              "rows": [
                ["Requirement", "0", "Sort_Critical", "Mechanized proof"],
                ["Requirement", "1", "Sort_High", "TLA+ model checking"],
                ["Requirement", "2", "Sort_Medium", "Property-based testing"],
                ["Requirement", "3", "Sort_Low", "Unit testing"],
                ["Constraint", "0", "Sort_Critical", "SMT + manual review"],
                ["Constraint", "1", "Sort_High", "SMT verification"],
                ["Constraint", "2", "Sort_Medium", "SMT verification"],
                ["Constraint", "3", "Sort_Low", "Review only"]
              ]
            },
            {
              "type": "paragraph",
              "text": "Type-to-sort mapping function:"
            },
            {
              "type": "code",
              "language": "typescript",
              "lines": [
                "function mapToSort(element: Element, layer: Layer): Sort {",
                "  return SORT_MAP[layer.tier] ?? Sort_Low;",
                "}",
                "",
                "const SORT_MAP = {",
                "  0: Sort_Critical,",
                "  1: Sort_High,",
                "  2: Sort_Medium,",
                "  3: Sort_Low",
                "};"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "sec-12",
      "number": "12",
      "title": "Summary",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "**STRATUM FORMAL SPECIFICATION - Version 2.5.0-alpha**"
        },
        {
          "type": "paragraph",
          "text": "This specification defines a comprehensive type system and formal semantics for safety-critical concurrent systems. The STRATUM framework provides:"
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Core Contributions"
        },
        {
          "type": "list",
          "items": [
            "**Formal Foundations (¬ß1-6)**: Type system, abstract syntax, well-formedness, and seven guarantees (G1-G7)",
            "**Operations & Profiles (¬ß7-9)**: Query operations, domain profiles, and extension mechanisms",
            "**Formal Theory (¬ß10-27)**: Theorems, concurrency semantics, compositional properties, certification artifacts, and safety integration",
            "**Implementation Support (¬ß11, ¬ß17-18)**: Reference implementation, proof templates, and language checklists",
            "**Safety Standards (¬ß17-18, ¬ß26-29)**: DO-178C/DO-330 compliance, ISO 26262 coverage, STPA/FMEA integration, and cross-standard traceability"
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Key Theorems"
        },
        {
          "type": "list",
          "items": [
            "**Type Soundness (Theorem 10.1)**: Well-typed programs cannot reach undefined states",
            "**Progress (Theorem 10.2)**: Non-stuck evaluation for all well-formed definitions",
            "**Preservation (Theorem 10.3)**: Type safety maintained across reduction steps",
            "**GC Correctness (Theorem 17.1-17.3)**: Garbage collection preserves observable semantics"
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Certification Path"
        },
        {
          "type": "paragraph",
          "text": "STRATUM provides formal evidence for:\n- Safety claim verification (ISO 26262 ASIL A-D)\n- Functional safety compliance (IEC 61508 SIL 1-4)\n- Assurance case support through mechanized proofs\n- Tool qualification evidence for language implementations"
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Structure Overview"
        },
        {
          "type": "paragraph",
          "text": "The specification is organized in six logical parts:\n- **PART I: Foundations** (¬ß1-6): Core type system, abstract syntax, well-formedness, guarantees, inference rules\n- **PART II: Operations** (¬ß7-9): Query operations, domain profiles, extension mechanisms\n- **PART III: Formal Theory** (¬ß10, ¬ß13-14, ¬ß16, ¬ß21-24, ¬ß28, ¬ß30): Theorems, proofs, concurrency, temporal properties, attenuation\n- **PART IV: Implementation** (¬ß11, ¬ß19-20): Reference implementation, proof templates, checklists\n- **PART V: Certification** (¬ß17-18, ¬ß26-27, ¬ß29): Certification artifacts, tool qualification, coverage matrices, STPA/FMEA, traceability\n- **PART VI: Appendices** (¬ß12, ¬ß31, ¬ß32): Summary, glossary, bibliography"
        }
      ]
    },
    {
      "id": "sec-31",
      "number": "31",
      "title": "Glossary of Key Terms",
      "defs": [],
      "overview": "Consolidated index of 100+ definitions used throughout the specification",
      "content": [
        {
          "type": "paragraph",
          "text": "This glossary provides quick reference to key terms and definitions appearing across all 30 sections of the STRATUM specification. Terms are organized alphabetically with cross-references to defining sections."
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Core Concepts (¬ß1-6)"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "Binding (b)",
              "definition": "Connection between abstract element and concrete realization. Defined: Definition 2.22 (¬ß2.5). See also: Groundedness (G4, ¬ß4.4)"
            },
            {
              "term": "Cascade",
              "definition": "Propagation of element changes across dependencies. Defined: Definition 2.26 (¬ß2.6). Rules: CASCADE-1, CASCADE-N (¬ß6)"
            },
            {
              "term": "Constraint (c)",
              "definition": "Assertion about specification elements with priority levels. Defined: Definition 2.16 (¬ß2.4). Categories: Traceability, Completeness, Consistency"
            },
            {
              "term": "Dependency (d)",
              "definition": "Link between elements with delta semantics. Defined: Definition 2.11 (¬ß2.3). Types: traces_to, implements, depends_on, satisfies"
            },
            {
              "term": "Element (e)",
              "definition": "Atomic unit of specification with identity, type, layer, properties, metadata. Defined: Definition 2.1 (¬ß2.1)"
            },
            {
              "term": "Layer (l)",
              "definition": "Level of abstraction containing elements. Defined: Definition 2.4 (¬ß2.2). Tiers: motivation ‚Üí logical ‚Üí realization ‚Üí grounding"
            },
            {
              "term": "Specification (S)",
              "definition": "Formal document with elements, layers, dependencies, constraints, bindings, cascades, reasoning. Defined: Definition 2.9 (¬ß2.5)"
            },
            {
              "term": "Type (œÑ)",
              "definition": "Element classification with variance rules. Defined: Definition 5.1 (¬ß5). Variance: strict, covariant, contravariant"
            },
            {
              "term": "Well-Formedness",
              "definition": "Conditions ensuring specification validity. Rules: WF-ID through WF-ACYCLIC-HARD (¬ß3)"
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "The Six Guarantees (¬ß4)"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "G1: Traceability",
              "definition": "Every element traces back to root in motivation tier. Formula: ‚àÄ e ‚àà E. ‚àÉ e' ‚àà E. root(e') ‚àß reachable(e, e', traces_to)"
            },
            {
              "term": "G2: Completeness",
              "definition": "All error-level constraints satisfied. Formula: ‚àÄ c ‚àà ErrorConstraints(S). S ‚ä® c"
            },
            {
              "term": "G3: Consistency",
              "definition": "No contradictory properties between elements. Formula: ‚àÄ e‚ÇÅ, e‚ÇÇ ‚àà E. ¬¨contradiction(e‚ÇÅ, e‚ÇÇ)"
            },
            {
              "term": "G4: Groundedness",
              "definition": "Every leaf element has binding to physical reality. Formula: ‚àÄ e ‚àà E. leaf(e) ‚Üí bound(e)"
            },
            {
              "term": "G5: Determinism",
              "definition": "Impact of changes is computable. Formula: ‚àÄ Œ¥. impact(S, Œ¥) is decidable"
            },
            {
              "term": "G6: Coherence",
              "definition": "Dependencies flow from concrete to abstract (except traces_to). Formula: ‚àÄ d ‚àà D. pos(layer(d.src)) ‚â• pos(layer(d.tgt)) ‚à® d.Œ¥ = traces_to"
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Type System (¬ß5)"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "Covariance",
              "definition": "Type relation where œÑ‚ÇÅ <: œÑ‚ÇÇ implies Container(œÑ‚ÇÅ) <: Container(œÑ‚ÇÇ). Used for outputs/return types. Rule: COV-SUBTYPE (¬ß5)"
            },
            {
              "term": "Contravariance",
              "definition": "Type relation where œÑ‚ÇÅ <: œÑ‚ÇÇ implies Container(œÑ‚ÇÇ) <: Container(œÑ‚ÇÅ). Used for inputs/parameters. Rule: CONTRA-SUBTYPE (¬ß5)"
            },
            {
              "term": "Strict Subtyping",
              "definition": "No variance applied; types must match exactly. Used for invariant contexts. Rule: STRICT-SUBTYPE (¬ß5)"
            },
            {
              "term": "Subtyping Relation (<:)",
              "definition": "Partial order on types enabling substitution. Reflexive, transitive, respects layer tier boundaries. Rules: REFL, TRANS (¬ß5)"
            },
            {
              "term": "QF-LIRA + EUF",
              "definition": "Quantifier-Free Linear Integer/Real Arithmetic with Equality and Uninterpreted Functions. Decidable constraint language used for predicates. SMT-LIB standard fragment. Definition 2.12 (¬ß2)"
            },
            {
              "term": "Type Judgment",
              "definition": "Assertion that element e has type œÑ in context Œì. Notation: Œì ‚ä¢ e : œÑ. Rules: ELEM-TYPE, LAYER-TYPE (¬ß6)"
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Operations & Semantics (¬ß7, ¬ß10-11)"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "bind(e, conc, ev, proof)",
              "definition": "Establish binding from abstract element to concrete realization with evidence and proof. Operation 7.5 (¬ß7)"
            },
            {
              "term": "coverage(S, concern)",
              "definition": "Measure of specification completeness w.r.t. concern. Returns [0, 1]. Operation 7.4 (¬ß7)"
            },
            {
              "term": "diff(S‚ÇÅ, S‚ÇÇ)",
              "definition": "Compute structural differences between specifications. Returns added, removed, modified elements. Operation 7.6 (¬ß7)"
            },
            {
              "term": "impact(S, Œ¥)",
              "definition": "Compute cascade propagation of change Œ¥. Returns affected elements. Operation 7.7 (¬ß7)"
            },
            {
              "term": "merge(S‚ÇÅ, S‚ÇÇ)",
              "definition": "Combine specifications, resolving conflicts via constraint priorities. Returns merged specification. Operation 7.8 (¬ß7)"
            },
            {
              "term": "trace(e)",
              "definition": "Find all elements reachable from e via traces_to dependencies. Operation 7.2 (¬ß7)"
            },
            {
              "term": "validate(S)",
              "definition": "Check all well-formedness conditions and constraint satisfactions. Operation 7.1 (¬ß7). Returns Result with violations"
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Inference Rules & Judgments (¬ß6)"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "CASCADE-1",
              "definition": "Single-step cascade computation: Œ¥ triggers immediate dependent changes"
            },
            {
              "term": "CASCADE-N",
              "definition": "Multi-step cascade: transitive closure of CASCADE-1"
            },
            {
              "term": "CONSTR-SAT",
              "definition": "Constraint satisfaction check: c.œÜ(elements, deps) evaluates to ‚ä§"
            },
            {
              "term": "SPEC-VALID",
              "definition": "Specification validation: All WF-* rules hold AND all constraints satisfied"
            },
            {
              "term": "SPEC-WF",
              "definition": "Well-formedness judgment for specification. Prerequisite for SPEC-VALID"
            },
            {
              "term": "TRACE-ROOT",
              "definition": "Base case: root element (motivation tier, no incoming traces_to)"
            },
            {
              "term": "TRACE-STEP",
              "definition": "Inductive step: follow traces_to dependencies backward to root"
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Advanced Semantics (¬ß12-19)"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "Attenuation Function",
              "definition": "Maps elements to monotonically-decreasing impact magnitude. Limits cascade propagation. Defined: ¬ß18 (Formal Attenuation Properties)"
            },
            {
              "term": "Binding Verification",
              "definition": "Lifecycle: unverified ‚Üí verified ‚Üí trusted with evidence trail. State machine: ¬ß14 (Binding Verification)"
            },
            {
              "term": "CRDT (Conflict-free Replicated Data Type)",
              "definition": "Concurrent data structure enabling merge without coordination. Used for concurrency semantics ¬ß13. Papers: Shapiro et al. 2011"
            },
            {
              "term": "LWW-Element-Set",
              "definition": "Last-Writer-Wins Element Set CRDT. Resolves concurrent add/remove conflicts by timestamp. Definition 21.3 (¬ß21). Used for element merging in specification synchronization"
            },
            {
              "term": "Schema Evolution",
              "definition": "Controlled changes to specification structure. Categories: backward_compatible, forward_compatible, breaking. ¬ß16"
            },
            {
              "term": "Temporal Properties",
              "definition": "Assertions about specification behavior over time using LTL/TLA+. Properties: ‚ñ° (always), ‚óá (eventually), U (until). ¬ß22"
            },
            {
              "term": "Tier Boundaries",
              "definition": "Architectural boundaries between motivation-logical-realization-grounding. Enforced by coherence (G6). ¬ß2.2, ¬ß30"
            },
            {
              "term": "Tombstone",
              "definition": "CRDT deletion marker preserving causal history. Prevents resurrection of deleted elements in concurrent environments. Used in CRDT garbage collection (Theorem 17.1-17.3) with logical timestamps for semantic preservation"
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Formal Properties & Proofs (¬ß10, ¬ß17-21)"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "Completeness (Theorem 10.4-10.6)",
              "definition": "Formal spec decidable w.r.t. all constraints. If valid manually, algorithm accepts. Proof by SMT solver (Z3/Dafny)"
            },
            {
              "term": "Decidability (Theorem 10.7-10.10)",
              "definition": "Well-formedness and constraint satisfaction are decidable problems. Proof: reduction to first-order logic with QE"
            },
            {
              "term": "GC Correctness (Theorem 17.1-17.3)",
              "definition": "CRDT garbage collection preserves observable semantics. Proof using logical time stamps and tombstone analysis"
            },
            {
              "term": "Preservation (Theorem 10.11-10.13)",
              "definition": "Type safety maintained across reduction steps. If Œì ‚ä¢ e : œÑ and e ‚ÜíŒ≤ e' then Œì ‚ä¢ e' : œÑ. Standard proof technique"
            },
            {
              "term": "Progress (Theorem 10.2)",
              "definition": "Non-stuck evaluation: Well-formed specifications don't reach undefined states. Proof by contradiction using reduction semantics"
            },
            {
              "term": "Soundness (Theorem 10.1-10.3)",
              "definition": "Type soundness: If ‚ä¢ S then S satisfies all well-formedness conditions. Proof by structural induction on type derivations"
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Safety & Certification (¬ß23-27)"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "ASIL (Automotive Safety Integrity Level)",
              "definition": "ISO 26262 levels A-D for safety-critical automotive systems. ASIL-D highest. Maps to SIL 3-4 (IEC 61508)"
            },
            {
              "term": "DO-178C",
              "definition": "FAA guidance for software in airborne systems. Covers planning, development, testing, certification. 71 objectives with STRATUM mapping"
            },
            {
              "term": "DO-330",
              "definition": "Tool qualification for avionics software tools. Guidance for qualifying compilers, analyzers, generators. ¬ß18"
            },
            {
              "term": "FMEA (Failure Mode & Effects Analysis)",
              "definition": "Bottom-up hazard analysis: element ‚Üí failure modes ‚Üí effects ‚Üí mitigations. Integrated with STRATUM ¬ß26.3"
            },
            {
              "term": "FTA (Fault Tree Analysis)",
              "definition": "Top-down hazard analysis: system hazard ‚Üí causes ‚Üí gate logic ‚Üí basic events. Integrated via STRATUM elements ¬ß26.3"
            },
            {
              "term": "IEC 61508",
              "definition": "Functional Safety standard for E/E/PE systems. SIL 1-4 levels. Generic framework; STRATUM harmonizes via attenuation ¬ß18"
            },
            {
              "term": "RTM (Requirements Traceability Matrix)",
              "definition": "Maps hazards ‚Üí UCAs ‚Üí safety constraints ‚Üí STRATUM constraints ‚Üí formal properties. Artifact: ¬ß17"
            },
            {
              "term": "STPA (System-Theoretic Process Analysis)",
              "definition": "Control-theoretic hazard analysis by Leveson. Models control structures, UCAs, scenarios. Integrated ¬ß26.2"
            },
            {
              "term": "UCA (Unsafe Control Action)",
              "definition": "Control action that, in a given context, can lead to hazard. Types: not provided, provided incorrectly, wrong timing, stopped too soon, wrong direction. ¬ß26.2"
            }
          ]
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Mathematical & Implementation Terms"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "Coq",
              "definition": "Interactive theorem prover for mechanized proofs. STRATUM proof templates in ¬ß19 for soundness/preservation"
            },
            {
              "term": "Domain Profile",
              "definition": "Configuration of constraint vocabulary and semantic properties for specific domain. Examples: Software Systems, Manufacturing, Healthcare. ¬ß8"
            },
            {
              "term": "Extension Mechanism",
              "definition": "Method to add custom constraint packs and semantic rules. Composition via union with priority resolution. ¬ß9"
            },
            {
              "term": "Lean",
              "definition": "Functional programming language with dependent types for mechanized proofs. Alternative to Coq/TLA+. ¬ß19"
            },
            {
              "term": "Metadata (Œº)",
              "definition": "Record: ‚ü®created, updated, version, status, actor, clock‚ü©. Enables audit trail and CRDT causality. Definition 2.2 (¬ß2.1)"
            },
            {
              "term": "Property (œÄ)",
              "definition": "Element attribute: partial function NAME ‚Üí VALUE. Type constraints per layer TYPE. Definition 2.1 (¬ß2.1)"
            },
            {
              "term": "TLA+ (Temporal Logic of Actions)",
              "definition": "Formal specification language by Lamport for distributed systems. Used for temporal properties (¬ß22) and proof templates (¬ß19)"
            },
            {
              "term": "Vector Clock",
              "definition": "ACTOR ‚Üí ‚Ñï mapping for causality tracking in concurrent systems. Enables version vectors and CRDT commutativity. Definition 2.3 (¬ß2.1)"
            },
            {
              "term": "Zod",
              "definition": "TypeScript-first schema validation library. STRATUM reference implementation schemas. ¬ß11"
            }
          ]
        }
      ]
    },
    {
      "id": "sec-32",
      "number": "32",
      "title": "Comprehensive Bibliography",
      "defs": [],
      "children": [
        {
          "id": "sec-32-1",
          "number": "32.1",
          "title": "Type Soundness & Covariant Subtyping",
          "defs": [],
          "content": [
            {
              "type": "reference",
              "key": "Wright-Felleisen-1994",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ CANONICAL",
              "citation": "Wright, A.K. and Felleisen, M. \"A Syntactic Approach to Type Soundness\" Information and Computation, 115(1):38-94, 1994. DOI: 10.1006/inco.1994.1093",
              "use": "Progress + Preservation proof structure (¬ß2.1, Theorem 2.1)"
            },
            {
              "type": "reference",
              "key": "Amin-Tate-2016",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ CRITICAL",
              "citation": "Amin, N. and Tate, R. \"Java and Scala's Type Systems are Unsound: The Existential Crisis of Null Pointers through Covariant Containers\" OOPSLA 2016, pp. 838-848. DOI: 10.1145/2983990.2984004",
              "use": "Why INV-1 (immutability) is required for covariant soundness (¬ß2.1)"
            },
            {
              "type": "reference",
              "key": "Jung-2018-RustBelt",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ GOLD STANDARD",
              "citation": "Jung, R., Jourdan, J.-H., Krebbers, R., and Dreyer, D. \"RustBelt: Securing the Foundations of the Rust Programming Language\" POPL 2018, Article 66. DOI: 10.1145/3158154",
              "use": "Interior mutability escape hatches, mechanized soundness (¬ß2.1, ¬ß19)"
            },
            {
              "type": "reference",
              "key": "Pierce-2002-TAPL",
              "rating": "‚òÖ‚òÖ‚òÖ TEXTBOOK",
              "citation": "Pierce, B.C. \"Types and Programming Languages\" MIT Press, 2002. ISBN: 978-0262162098",
              "use": "Variance fundamentals (Chapter 19), subtyping (Chapter 15)"
            }
          ]
        },
        {
          "id": "sec-32-2",
          "number": "32.2",
          "title": "Constraint Decidability (SMT)",
          "defs": [],
          "content": [
            {
              "type": "reference",
              "key": "Nelson-Oppen-1979",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ FOUNDATIONAL",
              "citation": "Nelson, G. and Oppen, D.C. \"Simplification by Cooperating Decision Procedures\" ACM TOPLAS, 1(2):245-257, 1979. DOI: 10.1145/357073.357079",
              "use": "Theory combination theorem (QF-LIRA + EUF decidability) (¬ß2.4)"
            },
            {
              "type": "reference",
              "key": "Bansal-2017-CVC5",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ CRITICAL",
              "citation": "Bansal, K., Reynolds, A., Barrett, C., and Tinelli, C. \"A New Decision Procedure for Finite Sets and Cardinality Constraints in SMT\" IJCAR 2016, LNCS 9706, pp. 82-98. DOI: 10.1007/978-3-319-40229-1_7",
              "use": "count() decidability via finite sets theory (¬ß2.4, Theorem 2.2)"
            }
          ]
        },
        {
          "id": "sec-32-3",
          "number": "32.3",
          "title": "CRDT Convergence & Composition [v2.4]",
          "defs": [],
          "content": [
            {
              "type": "reference",
              "key": "Shapiro-2011-CRDT",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ FOUNDATIONAL",
              "citation": "Shapiro, M., Pregui√ßa, N., Baquero, C., and Zawirski, M. \"Conflict-free Replicated Data Types\" SSS 2011, LNCS 6976, pp. 386-400. DOI: 10.1007/978-3-642-24550-3_29",
              "use": "SEC theorem, ACI requirements (¬ß11, Theorem 11.1)"
            },
            {
              "type": "reference",
              "key": "Gomes-2017-Automerge",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ MECHANIZED",
              "citation": "Gomes, V., Kleppmann, M., Mulligan, D., and Beresford, A. \"Verifying Strong Eventual Consistency in Distributed Systems\" OOPSLA 2017, Article 109. DOI: 10.1145/3133933. Distinguished Paper Award.",
              "use": "Isabelle/HOL CRDT proofs methodology (¬ß11, ¬ß21)"
            },
            {
              "type": "reference",
              "key": "iasakura-lean-yjs-2025",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ VERIFIED",
              "citation": "iasakura. \"lean-yjs: Lean 4 formalization of Yjs/YATA\" GitHub, 2025.",
              "use": "Lean 4 CRDT verification (¬ß11)"
            },
            {
              "type": "reference",
              "key": "Laddad-2022-Katara",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ SYNTHESIS",
              "citation": "Laddad, S., et al. \"Katara: Synthesizing CRDTs with Verified Lifting\" OOPSLA 2022. DOI: 10.1145/3563336",
              "use": "SMT-based CRDT synthesis (¬ß11)"
            },
            {
              "type": "reference",
              "key": "Zakhour-2023-PLDI",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ TYPE-CHECKING",
              "citation": "Zakhour, S., et al. \"Type-Checking CRDT Convergence\" PLDI 2023. DOI: 10.1145/3591276",
              "use": "Static verification of CRDT convergence (¬ß11)"
            },
            {
              "type": "reference",
              "key": "Cousineau-2012-TLA",
              "rating": "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ FOUNDATIONAL",
              "citation": "Cousineau, D., Doligez, D., Lamport, L., et al. \"TLA+ Proofs\" FM 2012, LNCS 7436. DOI: 10.1007/978-3-642-32759-9_14",
              "use": "TLA+ proof system (¬ß21)"
            }
          ]
        }
      ]
    }
  ]
}