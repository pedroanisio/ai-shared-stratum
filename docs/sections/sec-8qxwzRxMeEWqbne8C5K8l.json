{
  "id": "sec-8qxwzRxMeEWqbne8C5K8l",
  "title": "Abstract Syntax",
  "defs": [],
  "children": [
    {
      "id": "sub-xYOy8xUJpcssgjNVmANNW",
      "title": "Element",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "An Element is the atomic unit of specification."
        },
        {
          "type": "definition",
          "label": "Definition 2.1 (Element)",
          "text": "e ::= ‚ü®id, œÑ, l, œÄ, Œº‚ü©"
        },
        {
          "type": "paragraph",
          "text": "where:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "id ‚àà ID",
              "definition": "Unique identifier"
            },
            {
              "term": "œÑ ‚àà TYPE",
              "definition": "Element type (from layer's type vocabulary)"
            },
            {
              "term": "l ‚àà ID",
              "definition": "Layer identifier (membership) [IMMUTABLE - see ¬ß5.3] ‚üπ Forward reference explained in Type System section"
            },
            {
              "term": "œÄ : NAME ‚Üí VALUE",
              "definition": "Properties (partial function)"
            },
            {
              "term": "Œº : METADATA",
              "definition": "Metadata record"
            }
          ]
        },
        {
          "type": "admonition",
          "level": "critical",
          "text": "CRITICAL INVARIANT [v2.0]: The layer component 'l' is IMMUTABLE after creation. This enables covariant subtyping in ¬ß5.3 while maintaining type soundness. To change an element's layer, delete and recreate with new layer assignment."
        },
        {
          "type": "definition",
          "label": "Definition 2.2 (Metadata)",
          "text": "METADATA = ‚ü®created: TIME, updated: TIME, version: VersionVector, status: STATUS, actor: ACTOR, clock: CLOCK‚ü©"
        },
        {
          "type": "paragraph",
          "text": "STATUS = {draft, active, deprecated, archived}"
        },
        {
          "type": "definition",
          "label": "Definition 2.3 (Version Vector) [v2.0]",
          "text": "VersionVector = ACTOR ‚Üí ‚Ñï"
        },
        {
          "type": "paragraph",
          "text": "Operations:"
        },
        {
          "type": "code",
          "lines": [
            "vv‚ÇÅ ‚â§ vv‚ÇÇ  iff  ‚àÄŒ±. vv‚ÇÅ(Œ±) ‚â§ vv‚ÇÇ(Œ±)     -- partial order",
            "vv‚ÇÅ ‚äî vv‚ÇÇ  =  ŒªŒ±. max(vv‚ÇÅ(Œ±), vv‚ÇÇ(Œ±))   -- join (supremum)",
            "inc(vv, Œ±) =  vv[Œ± ‚Ü¶ vv(Œ±) + 1]          -- increment"
          ]
        },
        {
          "type": "paragraph",
          "text": "Notation: e.id, e.œÑ, e.l, e.œÄ, e.Œº for projections"
        }
      ],
      "suffix": "1"
    },
    {
      "id": "sub-1PQdtQJCcUP4hsmjE7iJL",
      "title": "Layer",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "A Layer is a level of abstraction containing elements."
        },
        {
          "type": "definition",
          "label": "Definition 2.4 (Tier)",
          "text": "TIER = {motivation, logical, realization, grounding}"
        },
        {
          "type": "paragraph",
          "text": "with total order: motivation < logical < realization < grounding"
        },
        {
          "type": "definition",
          "label": "Definition 2.5 (Tier Semantics) [v2.0]",
          "text": "The tier ordering represents REFINEMENT direction:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "motivation",
              "definition": "WHY - goals, values, and rationale"
            },
            {
              "term": "logical",
              "definition": "WHAT - abstract design and contracts"
            },
            {
              "term": "realization",
              "definition": "HOW - concrete implementation approach"
            },
            {
              "term": "grounding",
              "definition": "WHERE - physical artifacts and bindings"
            }
          ]
        },
        {
          "type": "paragraph",
          "text": "Refinement: tier(l‚ÇÅ) < tier(l‚ÇÇ) means l‚ÇÇ REFINES l‚ÇÅ (l‚ÇÇ provides more concrete details implementing l‚ÇÅ's abstractions). This is analogous to MDA's CIM ‚Üí PIM ‚Üí PSM progression. **Dependency arrows point FROM concrete TO abstract** (e.g., realization ‚Üí logical, meaning concrete elements DEPEND ON abstract specifications). This is enforced by Coherence (G6): pos(src) ‚â• pos(tgt). See ¬ß2.3 for dependency direction vs impact flow clarification."
        },
        {
          "type": "diagram",
          "format": "ascii",
          "content": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                                                                     ‚îÇ\n‚îÇ                         TIER FLOW DIAGRAM                           ‚îÇ\n‚îÇ                                                                     ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ  MOTIVATION (WHY)                                           ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îÇ  Goal   ‚îÇ  ‚îÇ  Value  ‚îÇ  ‚îÇ  Metric ‚îÇ                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ          ‚îÇ traces_to ‚ñ≤‚îÇ            ‚îÇ  ‚óÑ‚îÄ‚îÄ UPWARD (certification)   ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ  LOGICAL (WHAT)    ‚îÇ            ‚îÇ                           ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îÇComponent‚îÇ  ‚îÇ Contract‚îÇ  ‚îÇ   API   ‚îÇ                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ          ‚ñº realizes   ‚ñº requires   ‚ñº  ‚óÑ‚îÄ‚îÄ DOWNWARD (refinement)    ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ  REALIZATION (HOW) ‚îÇ            ‚îÇ                           ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îÇ  Module ‚îÇ  ‚îÇ  Config ‚îÇ  ‚îÇ Pipeline‚îÇ                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ          ‚ñº realizes   ‚ñº            ‚ñº                               ‚îÇ\n‚îÇ          ‚îÇ            ‚îÇ            ‚îÇ                               ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ  GROUNDING (WHERE) ‚îÇ            ‚îÇ                           ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îÇ  File   ‚îÇ  ‚îÇ Symbol  ‚îÇ  ‚îÇ  Line   ‚îÇ  ‚Üê‚îÄ‚îÄ Bindings        ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ                                                                     ‚îÇ\n‚îÇ  LEGEND:                                                            ‚îÇ\n‚îÇ    ‚ñº realizes/requires  = Refinement (downward, cascade attenuates)‚îÇ\n‚îÇ    ‚ñ≤ traces_to          = Certification (upward, cascade blocked)  ‚îÇ\n‚îÇ                                                                     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
          "caption": "Figure 2.1: Tier flow showing the asymmetry between dependency direction (realizes/requires go downward) and traces_to (upward for certification). Impact cascades follow dependency arrows with attenuation across tier boundaries.",
          "alt": "Diagram showing four tiers (Motivation, Logical, Realization, Grounding) with downward refinement dependencies (realizes/requires) and upward certification dependencies (traces_to). Cascade attenuation occurs on downward propagation."
        },
        {
          "type": "definition",
          "label": "Definition 2.6 (Layer)",
          "text": "l ::= ‚ü®id, name, tier, order, Q, T, deps‚ü©"
        },
        {
          "type": "paragraph",
          "text": "where:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "id ‚àà ID",
              "definition": "Unique identifier"
            },
            {
              "term": "name ‚àà NAME",
              "definition": "Human-readable name"
            },
            {
              "term": "tier ‚àà TIER",
              "definition": "Which tier this layer belongs to"
            },
            {
              "term": "order ‚àà ‚Ñï",
              "definition": "Position within tier (0 = most abstract)"
            },
            {
              "term": "Q ‚àà NAME",
              "definition": "The question this layer answers"
            },
            {
              "term": "T ‚äÜ TYPE",
              "definition": "Vocabulary of element types"
            },
            {
              "term": "deps ‚äÜ ID",
              "definition": "Layer dependencies (required layers)"
            }
          ]
        },
        {
          "type": "definition",
          "label": "Definition 2.7 (Layer Position)",
          "text": "pos(l) = ‚ü®l.tier, l.order‚ü©"
        },
        {
          "type": "paragraph",
          "text": "Ordering: pos(l‚ÇÅ) < pos(l‚ÇÇ) iff l‚ÇÅ.tier < l‚ÇÇ.tier ‚à® (l‚ÇÅ.tier = l‚ÇÇ.tier ‚àß l‚ÇÅ.order < l‚ÇÇ.order)"
        }
      ],
      "suffix": "2"
    },
    {
      "id": "sub-przG8f9oPcQ5oNMXdlyHX",
      "title": "Dependency",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "A Dependency is a directed relationship between elements."
        },
        {
          "type": "definition",
          "label": "Definition 2.8 (Dependency Type)",
          "text": "DEPTYPE = {realizes, requires, produces, consumes, constrains, validates, traces_to}"
        },
        {
          "type": "definition",
          "label": "Definition 2.9 (Strength)",
          "text": "STRENGTH = {hard, soft}"
        },
        {
          "type": "paragraph",
          "text": "Semantics:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "hard",
              "definition": "Breaking this dependency invalidates the specification"
            },
            {
              "term": "soft",
              "definition": "Breaking this dependency degrades but doesn't invalidate"
            }
          ]
        },
        {
          "type": "definition",
          "label": "Definition 2.10 (Cardinality)",
          "text": "CARDINALITY = {one_to_one, one_to_many, many_to_one, many_to_many}"
        },
        {
          "type": "definition",
          "label": "Definition 2.11 (Dependency)",
          "text": "d ::= ‚ü®id, src, tgt, Œ¥, œÉ, Œ∫, cascade_boundary‚ü©"
        },
        {
          "type": "paragraph",
          "text": "where:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "id ‚àà ID",
              "definition": "Unique identifier"
            },
            {
              "term": "src ‚àà ID √ó ID",
              "definition": "Source (element_id, layer_id)"
            },
            {
              "term": "tgt ‚àà ID √ó ID",
              "definition": "Target (element_id, layer_id)"
            },
            {
              "term": "Œ¥ ‚àà DEPTYPE",
              "definition": "Dependency type"
            },
            {
              "term": "œÉ ‚àà STRENGTH",
              "definition": "Hard or soft"
            },
            {
              "term": "Œ∫ ‚àà CARDINALITY",
              "definition": "Cardinality constraint"
            },
            {
              "term": "cascade_boundary ‚àà ùîπ",
              "definition": "Whether cascade propagation stops here [v2.0]"
            }
          ]
        },
        {
          "type": "admonition",
          "level": "important",
          "text": "**Dependency Direction vs Impact Flow Semantics [v2.4.4 Clarification]**\n\nDependencies have TWO distinct directional semantics:\n\n**1. Structural Direction (src ‚Üí tgt)**: The dependency arrow shows WHO depends ON WHOM.\n- `d.src ‚Üí d.tgt` means \"src depends on tgt\" (src is dependent, tgt is dependee)\n- `realizes`: concrete_impl ‚Üí abstract_spec (impl depends on spec)\n- `requires`: component_A ‚Üí component_B (A depends on B)\n- Coherence (G6): `pos(d.src) ‚â• pos(d.tgt)` (dependent ‚â• dependee in concreteness)\n\n**2. Impact Flow**: CASCADE walks deps where `d.src.elem = changed_element`, propagates to `d.tgt`.\n- When element e changes, impact flows TO elements e depends on\n- Example: Component C realizes Spec S ‚Üí dependency `C ‚Üí S`\n  - If C changes: cascade finds `d.src=C`, propagates impact to S ‚úì\n  - If S changes: cascade finds deps `d.src=S` (none of type realizes), no auto-propagation to C\n- This prevents circular cascades while maintaining traceability\n\n**Reconciling 'changes cascade down'**: This phrase in ¬ß4.6 means Coherence prevents upward structural dependencies (abstract layers don't depend on concrete). Impact flows along dependency arrows (dependent ‚Üí dependee), which by G6 is always same-tier or concrete‚Üíabstract."
        },
        {
          "type": "paragraph",
          "text": "Notation: src(d) = d.src, tgt(d) = d.tgt; d : e‚ÇÅ ‚Üí[Œ¥] e‚ÇÇ means dependency d from e‚ÇÅ to e‚ÇÇ of type Œ¥"
        }
      ],
      "suffix": "3"
    },
    {
      "id": "sub-CyAf_GsK2z3HhpvlCgKlD",
      "title": "Constraint",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "A Constraint is a rule that must hold across elements."
        },
        {
          "type": "admonition",
          "level": "note",
          "text": "SOUNDNESS FIX [v2.0]: The predicate language œÜ is now formally specified as a combination of QF_LIA, QF_LRA, and QF_UF (Quantifier-Free Linear Integer Arithmetic, Linear Real Arithmetic, and Uninterpreted Functions with Equality). This ensures decidability per SMT-LIB 2.6 standard using Nelson-Oppen combination."
        },
        {
          "type": "paragraph",
          "text": "**Definition 2.12 (Predicate Language - SMT-LIB Constraint Logic)**"
        },
        {
          "type": "paragraph",
          "text": "The constraint predicate language combines three decidable SMT-LIB theories:"
        },
        {
          "type": "list",
          "items": [
            "**QF_LIA**: Quantifier-Free Linear Integer Arithmetic (sort Int)",
            "**QF_LRA**: Quantifier-Free Linear Real Arithmetic (sort Real)",
            "**QF_UF**: Quantifier-Free Uninterpreted Functions with Equality"
          ]
        },
        {
          "type": "paragraph",
          "text": "**Sorts and Coercions**:"
        },
        {
          "type": "code",
          "lines": [
            "Sorts: Int, Real, Bool, Element, Layer, Dependency",
            "Coercion: to_real : Int ‚Üí Real (standard SMT-LIB coercion)",
            "No implicit coercion from Real to Int (explicit floor/ceil required)"
          ]
        },
        {
          "type": "paragraph",
          "text": "**Nelson-Oppen Requirements**: QF_LIA, QF_LRA, and QF_UF are stably infinite and have disjoint signatures (Int/Real arithmetic operators vs uninterpreted functions), satisfying combination requirements (Nelson & Oppen 1979)."
        },
        {
          "type": "paragraph",
          "text": "Terms:"
        },
        {
          "type": "code",
          "lines": [
            "t ::= x : œÉ                    -- Typed variable (œÉ ‚àà {Int, Real, Bool, Element, ...})",
            "    | n : Int                  -- Integer literal",
            "    | r : Real                 -- Real literal",
            "    | t‚ÇÅ + t‚ÇÇ | t‚ÇÅ - t‚ÇÇ        -- Addition, subtraction (same sort)",
            "    | n √ó t                    -- Scalar multiplication (n : Int)",
            "    | to_real(t)               -- Int ‚Üí Real coercion",
            "    | f(t‚ÇÅ, ..., t‚Çô)           -- Uninterpreted function (signature declared)",
            "    | e.œÄ(p) : VALUE           -- Property access (runtime value)",
            "    | |S| : Int                -- Set cardinality (finite sets only)",
            "    | count(S, pred) : Int     -- Counting with predicate (see below)"
          ]
        },
        {
          "type": "paragraph",
          "text": "**Finite Set Cardinality Semantics**: The `count(S, pred)` operator is defined for FINITE element sets only. Given a finite set S ‚äÜ E and predicate pred : E ‚Üí Bool, `count(S, pred) = |{e ‚àà S | pred(e)}|`. This is decidable because all specifications have finite E, L, D, C sets per ¬ß3 (WF-ID ensures finite identifiers)."
        },
        {
          "type": "admonition",
          "level": "important",
          "text": "**SMT Solver Requirements**: Constraints using |S| or count() require an SMT solver with BOTH QF_LIA/QF_LRA theory AND finite sets theory (e.g., Z3 with (set Int) or CVC5 with finite sets). Pure QF_LIA + QF_UF solvers cannot handle set cardinality. Implementations may choose to: (1) require sets-capable solver for full K0 conformance, OR (2) restrict Kernel to QF_LIA/LRA/UF only and treat |S|/count() as K1+ extensions."
        },
        {
          "type": "paragraph",
          "text": "Atomic Formulas:"
        },
        {
          "type": "code",
          "lines": [
            "a ::= t‚ÇÅ = t‚ÇÇ                  -- Equality",
            "    | t‚ÇÅ ‚â† t‚ÇÇ                  -- Disequality",
            "    | t‚ÇÅ < t‚ÇÇ | t‚ÇÅ ‚â§ t‚ÇÇ        -- Integer/real comparisons",
            "    | t‚ÇÅ > t‚ÇÇ | t‚ÇÅ ‚â• t‚ÇÇ",
            "    | e ‚àà S                    -- Set membership",
            "    | d : e‚ÇÅ ‚Üí e‚ÇÇ              -- Dependency existence"
          ]
        },
        {
          "type": "paragraph",
          "text": "Formulas (Quantifier-Free):"
        },
        {
          "type": "code",
          "lines": [
            "œÜ ::= a                        -- Atomic formula",
            "    | ¬¨œÜ                       -- Negation",
            "    | œÜ‚ÇÅ ‚àß œÜ‚ÇÇ                  -- Conjunction",
            "    | œÜ‚ÇÅ ‚à® œÜ‚ÇÇ                  -- Disjunction",
            "    | œÜ‚ÇÅ ‚áí œÜ‚ÇÇ                  -- Implication",
            "    | if œÜ‚ÇÅ then œÜ‚ÇÇ else œÜ‚ÇÉ   -- Conditional"
          ]
        },
        {
          "type": "paragraph",
          "text": "Bounded Quantification (decidable extension):"
        },
        {
          "type": "code",
          "lines": [
            "œÜ ::= ‚àÄ e ‚àà E_finite. œÜ        -- Universal over finite set",
            "    | ‚àÉ e ‚àà E_finite. œÜ        -- Existential over finite set"
          ]
        },
        {
          "type": "theorem",
          "label": "Theorem 2.1 (Constraint Decidability)",
          "text": "For any constraint c with predicate œÜ in QF_LIA + QF_LRA + QF_UF (combined via Nelson-Oppen): sat(œÜ) is decidable in NP (via SMT solving); unsat(œÜ) is decidable in co-NP"
        },
        {
          "type": "definition",
          "label": "Definition 2.13 (Constraint Category)",
          "text": "CATEGORY = {existence, uniqueness, completeness, consistency, validity, dependency, ordering, coverage, alignment, boundary}"
        },
        {
          "type": "definition",
          "label": "Definition 2.14 (Severity)",
          "text": "SEVERITY = {error, warning, info}"
        },
        {
          "type": "definition",
          "label": "Definition 2.15 (Scope)",
          "text": "scope ::= ‚ü®srcLayer: ID*, srcType: TYPE*, tgtLayer: ID*, tgtType: TYPE*‚ü©"
        },
        {
          "type": "definition",
          "label": "Definition 2.16 (Constraint)",
          "text": "c ::= ‚ü®id, name, scope, cat, sev, œÜ, msg, priority‚ü©"
        },
        {
          "type": "paragraph",
          "text": "where:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "id ‚àà ID",
              "definition": "Unique identifier"
            },
            {
              "term": "name ‚àà NAME",
              "definition": "Human-readable name"
            },
            {
              "term": "scope ‚àà SCOPE",
              "definition": "What elements this applies to"
            },
            {
              "term": "cat ‚àà CATEGORY",
              "definition": "Constraint category"
            },
            {
              "term": "sev ‚àà SEVERITY",
              "definition": "Violation severity"
            },
            {
              "term": "œÜ : P(E) √ó P(D) ‚Üí ùîπ",
              "definition": "Predicate (in SMT-LIB QF_LIA + QF_LRA + QF_UF)"
            },
            {
              "term": "msg : P(E) ‚Üí NAME",
              "definition": "Error message generator"
            },
            {
              "term": "priority ‚àà ‚Ñï",
              "definition": "For conflict resolution [v2.0]"
            }
          ]
        },
        {
          "type": "definition",
          "label": "Definition 2.17 (Constraint Satisfaction)",
          "text": "S ‚ä® c iff c.œÜ(elements(S), dependencies(S)) = ‚ä§"
        },
        {
          "type": "definition",
          "label": "Definition 2.18 (Constraint Conflict) [v2.0]",
          "text": "conflict(c‚ÇÅ, c‚ÇÇ) iff unsat(c‚ÇÅ.œÜ ‚àß c‚ÇÇ.œÜ)"
        },
        {
          "type": "heading",
          "level": 3,
          "text": "Normative SMT-LIB 2.6 Encoding"
        },
        {
          "type": "paragraph",
          "text": "**Definition 2.19 (SMT-LIB 2.6 Constraint Encoding) [v2.5]**: The following SMT-LIB 2.6 preamble defines the normative encoding for STRATUM constraints. Implementations MUST use this exact logic declaration and sort/function signatures for K0 conformance."
        },
        {
          "type": "code",
          "language": "smt2",
          "lines": [
            "; SMT-LIB 2.6 Standard Preamble for STRATUM Constraints",
            "(set-logic QF_AUFLIRA)  ; Combined logic: Arrays, Uninterpreted Functions, Linear Integer/Real Arithmetic",
            "",
            "; Core domain sorts",
            "(declare-sort Element 0)    ; Element identifiers",
            "(declare-sort Layer 0)      ; Layer identifiers",
            "(declare-sort Dependency 0) ; Dependency identifiers",
            "",
            "; Element projection functions (uninterpreted)",
            "(declare-fun elem-id (Element) Int)       ; Element ‚Üí unique integer ID",
            "(declare-fun elem-layer (Element) Layer)  ; Element ‚Üí Layer membership",
            "(declare-fun elem-type (Element) Int)     ; Element ‚Üí type code",
            "",
            "; Layer projection functions",
            "(declare-fun layer-tier (Layer) Int)      ; Layer ‚Üí tier code (0=motivation, 1=logical, 2=realization, 3=grounding)",
            "(declare-fun layer-order (Layer) Int)     ; Layer ‚Üí position within tier",
            "",
            "; Dependency projection functions",
            "(declare-fun dep-src (Dependency) Element)     ; Dependency ‚Üí source element",
            "(declare-fun dep-tgt (Dependency) Element)     ; Dependency ‚Üí target element",
            "(declare-fun dep-type (Dependency) Int)        ; Dependency ‚Üí type code",
            "(declare-fun dep-strength (Dependency) Int)    ; 0=soft, 1=hard",
            "",
            "; Property access function (uninterpreted, domain-specific)",
            "; Usage: (declare-fun prop-complexity (Element) Int)",
            "; Each property gets its own typed accessor function",
            "",
            "; Set cardinality (for finite element/dependency sets)",
            "; Encoded as integer constants: |E| = elem-count, |D| = dep-count",
            "(declare-const elem-count Int)",
            "(declare-const dep-count Int)",
            "(assert (>= elem-count 0))",
            "(assert (>= dep-count 0))",
            "",
            "; Tier ordering axioms (if needed for coherence constraints)",
            "; (assert (forall ((l1 Layer) (l2 Layer))",
            ";   (=> (< (layer-tier l1) (layer-tier l2))",
            ";       (< (layer-position l1) (layer-position l2)))))",
            "; Note: Quantifiers push logic to AUFLIRA (undecidable), avoid if possible"
          ]
        },
        {
          "type": "admonition",
          "level": "note",
          "text": "**Logic Selection Rationale**: QF_AUFLIRA combines four theories: Arrays (for element/dependency collections), Uninterpreted Functions (for property access), Linear Integer Arithmetic (for counts, tier codes), and Linear Real Arithmetic (for attenuation factors). This is the MINIMAL combined logic that supports all Kernel constraint patterns. Solvers: Z3 4.8+, CVC5 1.0+, MathSAT 5.6+ all support QF_AUFLIRA."
        },
        {
          "type": "paragraph",
          "text": "**Example Constraint**: Feature test coverage (¬ß4.2 completeness example) encoded in SMT-LIB 2.6:"
        },
        {
          "type": "code",
          "language": "smt2",
          "lines": [
            "; Constraint: ‚àÄ feature f. ‚àÉ test t. tests(t, f)",
            "; Property declarations",
            "(declare-fun is-feature (Element) Bool)",
            "(declare-fun is-test (Element) Bool)",
            "(declare-fun tests-feature (Dependency) Bool)  ; dep.type = validates",
            "",
            "; Finite quantification over elements (expanded to conjunction)",
            "; For specification with elements e1, e2, ..., en:",
            "(assert (=> (is-feature e1)",
            "            (or (and (tests-feature d1) (= (dep-src d1) t1) (= (dep-tgt d1) e1))",
            "                (and (tests-feature d2) (= (dep-src d2) t2) (= (dep-tgt d2) e1))",
            "                ; ... for all test elements t_i and dependencies d_j",
            "            )))",
            "; Repeat for e2, e3, ..., en",
            "",
            "; Alternative encoding using counting (requires finite sets extension):",
            "; (assert (forall ((f Element))",
            ";   (=> (is-feature f)",
            ";       (> (select feature-test-count f) 0))))",
            "; where (declare-fun feature-test-count (Array Element Int))"
          ]
        },
        {
          "type": "admonition",
          "level": "warning",
          "text": "**Bounded Quantification Trade-off**: Quantified formulas (‚àÄ, ‚àÉ) over finite element sets are DECIDABLE when expanded to finite conjunctions/disjunctions, but may cause exponential blowup. K0 implementations MAY choose to: (1) fully expand quantifiers at query-time (guarantees decidability, may be slow), OR (2) use heuristic quantifier instantiation (fast, may report 'unknown' for complex constraints). K1+ conformance REQUIRES full expansion with definite sat/unsat answers."
        },
        {
          "type": "paragraph",
          "text": "Resolution: When conflict(c‚ÇÅ, c‚ÇÇ), apply constraint with higher priority. If equal priority, flag for manual resolution."
        }
      ],
      "suffix": "4"
    },
    {
      "id": "sub-hokiwCzrIfE6qFGSucWVf",
      "title": "Binding",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "A Binding connects abstract elements to concrete artifacts."
        },
        {
          "type": "definition",
          "label": "Definition 2.19 (Binding Completeness)",
          "text": "COMPLETENESS = {complete, partial, stub}"
        },
        {
          "type": "definition",
          "label": "Definition 2.20 (Verification State) [v2.0]",
          "text": "VERIFICATION = {unverified, pending, verified, failed, stale}"
        },
        {
          "type": "paragraph",
          "text": "State transitions:"
        },
        {
          "type": "code",
          "lines": [
            "unverified ‚Üí pending   (verification initiated)",
            "pending ‚Üí verified     (verification succeeded)",
            "pending ‚Üí failed       (verification failed)",
            "verified ‚Üí stale       (bound artifact changed)",
            "stale ‚Üí pending        (re-verification initiated)",
            "failed ‚Üí pending       (retry verification)"
          ]
        },
        {
          "type": "definition",
          "label": "Definition 2.21 (Artifact Reference)",
          "text": "artifact ::= ‚ü®type: ARTIFACT_TYPE, uri: URI, hash: HASH, verified_at: TIME*‚ü©"
        },
        {
          "type": "paragraph",
          "text": "ARTIFACT_TYPE = {file, symbol, line_range, url, database_record, ...}"
        },
        {
          "type": "definition",
          "label": "Definition 2.22 (Binding)",
          "text": "b ::= ‚ü®id, abstract, concrete, completeness, verification, evidence‚ü©"
        },
        {
          "type": "paragraph",
          "text": "where:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "id ‚àà ID",
              "definition": "Unique identifier"
            },
            {
              "term": "abstract ‚àà ID √ó ID",
              "definition": "(element_id, layer_id)"
            },
            {
              "term": "concrete ‚àà ARTIFACT",
              "definition": "Physical artifact"
            },
            {
              "term": "completeness ‚àà COMPLETENESS",
              "definition": "How complete is the binding"
            },
            {
              "term": "verification ‚àà VERIFICATION",
              "definition": "Current verification state [EXPANDED]"
            },
            {
              "term": "evidence ‚àà List<EVIDENCE>",
              "definition": "Verification evidence [v2.0]"
            }
          ]
        },
        {
          "type": "definition",
          "label": "Definition 2.23 (Evidence) [v2.0]",
          "text": "evidence ::= ‚ü®type: EVIDENCE_TYPE, timestamp: TIME, result: ùîπ, details: VALUE‚ü©"
        },
        {
          "type": "paragraph",
          "text": "EVIDENCE_TYPE = {test_result, static_analysis, manual_review, audit_log, ...}"
        }
      ],
      "suffix": "5"
    },
    {
      "id": "sub-4p4RHhG9shx4eEYEWo2Uh",
      "title": "Cascade Rule",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "A Cascade Rule defines how changes propagate."
        },
        {
          "type": "definition",
          "label": "Definition 2.24 (Change Type)",
          "text": "CHANGE = {create, update, delete, deprecate}"
        },
        {
          "type": "definition",
          "label": "Definition 2.25 (Impact Level)",
          "text": "IMPACT = {‚ä•, cosmetic, degraded, breaking}"
        },
        {
          "type": "paragraph",
          "text": "with total order: ‚ä• < cosmetic < degraded < breaking"
        },
        {
          "type": "paragraph",
          "text": "‚ä• represents \"no impact\" - explicitly included for completeness"
        },
        {
          "type": "definition",
          "label": "Definition 2.26 (Cascade Rule)",
          "text": "r ::= ‚ü®id, trigger, propagation, effect‚ü©"
        },
        {
          "type": "paragraph",
          "text": "where:"
        },
        {
          "type": "code",
          "lines": [
            "trigger     = ‚ü®elementTypes: TYPE*, changeType: CHANGE‚ü©",
            "propagation = ‚ü®depTypes: DEPTYPE*, direction: DIR, maxDepth: ‚Ñï*, respectBoundary: ùîπ‚ü©",
            "effect      = ‚ü®severity: IMPACT, action: NAME, attenuates: ùîπ‚ü©"
          ]
        },
        {
          "type": "paragraph",
          "text": "DIR = {forward, backward, both}"
        },
        {
          "type": "paragraph",
          "text": "respectBoundary: if true, stop at dependencies with cascade_boundary = ‚ä§"
        }
      ],
      "suffix": "6"
    },
    {
      "id": "sub-G3_ARB8KVMkMvSpCFg6_y",
      "title": "Specification",
      "defs": [],
      "content": [
        {
          "type": "paragraph",
          "text": "A Specification is a complete STRATUM model."
        },
        {
          "type": "definition",
          "label": "Definition 2.27 (Specification)",
          "text": "S ::= ‚ü®id, name, domain, version, L, E, D, C, B, R, H‚ü©"
        },
        {
          "type": "paragraph",
          "text": "where:"
        },
        {
          "type": "definition-list",
          "items": [
            {
              "term": "id ‚àà ID",
              "definition": "Specification identifier"
            },
            {
              "term": "name ‚àà NAME",
              "definition": "Human-readable name"
            },
            {
              "term": "domain ‚àà NAME",
              "definition": "Domain profile identifier"
            },
            {
              "term": "version ‚àà VersionVector",
              "definition": "Causal version [v2.0 changed]"
            },
            {
              "term": "L ‚äÜ LAYER",
              "definition": "Set of layers"
            },
            {
              "term": "E ‚äÜ ELEMENT",
              "definition": "Set of elements"
            },
            {
              "term": "D ‚äÜ DEPENDENCY",
              "definition": "Set of dependencies"
            },
            {
              "term": "C ‚äÜ CONSTRAINT",
              "definition": "Set of constraints"
            },
            {
              "term": "B ‚äÜ BINDING",
              "definition": "Set of bindings"
            },
            {
              "term": "R ‚äÜ CASCADE_RULE",
              "definition": "Set of cascade rules"
            },
            {
              "term": "H ‚àà HISTORY",
              "definition": "Operation history for CRDT [v2.0]"
            }
          ]
        },
        {
          "type": "definition",
          "label": "Definition 2.28 (History) [v2.0]",
          "text": "H = List<Operation>; Operation = ‚ü®op_id: ID, actor: ACTOR, clock: CLOCK, type: OP_TYPE, payload‚ü©"
        },
        {
          "type": "paragraph",
          "text": "OP_TYPE = {add_element, remove_element, update_element, add_dep, ...}"
        }
      ],
      "suffix": "7"
    }
  ]
}
